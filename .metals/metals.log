2024.11.07 18:34:36 INFO  Started: Metals version 1.4.0 in folders 'C:\Users\User\hotel-bookinghotel-booking' for client Visual Studio Code 1.94.2.
2024.11.07 18:34:36 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.07 18:34:37 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.07 18:34:41 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
nov. 07, 2024 6:34:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3
nov. 07, 2024 6:34:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6
nov. 07, 2024 6:34:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2
nov. 07, 2024 6:34:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1
2024.11.07 18:34:45 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals4732317042186808911\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 18:34:45 ERROR [info] [launcher] getting org.scala-sbt sbt 1.10.5  (this may take some time)...
2024.11.07 18:34:49 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.07 18:34:49 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.07 18:34:51 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.07 18:34:58 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 18:35:00 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 18:35:00 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 18:35:05 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 18:35:05 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 18:35:12 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 18:35:12 INFO  [info] compiling 1 Scala source to C:\Users\User\hotel-bookinghotel-booking\project\target\scala-2.12\sbt-1.0\classes ...
2024.11.07 18:35:12 INFO  [info] Non-compiled module 'compiler-bridge_2.12' for Scala 2.12.20. Compiling...
2024.11.07 18:35:21 INFO  [info]   Compilation completed in 8.687s.
2024.11.07 18:35:23 INFO  [info] done compiling
2024.11.07 18:35:23 INFO  [success] Total time: 18 s, completed 7 de nov de 2024 18:35:24
2024.11.07 18:35:25 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 18:35:25 INFO  [info] set current project to hotel-bookinghotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 18:35:33 INFO  [success] Generated .bloop\root-test.json
2024.11.07 18:35:33 INFO  [success] Generated .bloop\root.json
2024.11.07 18:35:33 INFO  [success] Total time: 8 s, completed 7 de nov de 2024 18:35:33
2024.11.07 18:35:33 INFO  time: ran 'sbt bloopInstall' in 48s
2024.11.07 18:35:33 INFO  Attempting to connect to the build server...
2024.11.07 18:35:33 INFO  No running Bloop server found, starting one.
2024.11.07 18:35:48 INFO  Starting compilation server
2024.11.07 18:35:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:35:53 INFO  Attempting to connect to the build server...
2024.11.07 18:35:53 INFO  Found a Bloop server running
2024.11.07 18:35:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:35:55 INFO  time: Connected to build server in 21s
2024.11.07 18:35:55 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 18:35:55 INFO  time: Imported build in 0.16s
2024.11.07 18:35:55 INFO  running doctor check
2024.11.07 18:35:55 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
nov. 07, 2024 6:36:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19
2024.11.07 18:36:04 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.07 18:36:14 INFO  compiling root (2 scala sources)
2024.11.07 18:36:20 INFO  time: indexed workspace in 24s
2024.11.07 18:36:20 INFO  time: compiled root in 5.26s
2024.11.07 18:36:20 INFO  compiling root (2 scala sources)
2024.11.07 18:36:20 INFO  compiling hotel-bookinghotel-booking-build (1 scala source)
2024.11.07 18:36:20 INFO  Non-compiled module 'compiler-bridge_2.12' for Scala 2.12.20. Compiling...
2024.11.07 18:36:21 INFO  time: compiled root in 1.03s
2024.11.07 18:36:21 INFO  compiling root-test (1 scala source)
2024.11.07 18:36:21 INFO  time: compiled root-test in 0.88s
2024.11.07 18:36:30 INFO  Compilation completed in 9.567s.
2024.11.07 18:36:31 INFO  compiling root (1 scala source)
2024.11.07 18:36:31 INFO  time: compiled root in 0.57s
2024.11.07 18:36:34 INFO  time: compiled hotel-bookinghotel-booking-build in 13s
2024.11.07 18:36:35 INFO  time: code lens generation in 1.28s
2024.11.07 18:36:35 INFO  time: code lens generation in 1.28s
2024.11.07 18:36:38 INFO  compiling root (1 scala source)
2024.11.07 18:36:38 INFO  time: compiled root in 0.73s
2024.11.07 18:37:19 INFO  compiling root (1 scala source)
2024.11.07 18:37:19 INFO  time: compiled root in 0.34s
2024.11.07 18:38:03 INFO  compiling root (1 scala source)
2024.11.07 18:38:03 ERROR text document: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala
java.nio.file.FileSystemException: C:\Users\User\hotel-bookinghotel-booking\.bloop\root\bloop-bsp-clients-classes\classes-Metals-v0vy75ldQIeRtD0gtEUJ8Q==\META-INF\semanticdb\src\main\scala\Main.scala.semanticdb: O arquivo já está sendo usado por outro processo
	at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.nio.file.Files.newByteChannel(Files.java:380)
	at java.nio.file.Files.newByteChannel(Files.java:432)
	at java.nio.file.spi.FileSystemProvider.newInputStream(FileSystemProvider.java:422)
	at java.nio.file.Files.newInputStream(Files.java:160)
	at scala.meta.internal.mtags.Semanticdbs$.loadTextDocuments(Semanticdbs.scala:24)
	at scala.meta.internal.mtags.Semanticdbs$.loadResolvedTextDocument(Semanticdbs.scala:71)
	at scala.meta.internal.mtags.Semanticdbs$.loadTextDocument(Semanticdbs.scala:55)
	at scala.meta.internal.metals.FileSystemSemanticdbs.textDocument(FileSystemSemanticdbs.scala:67)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.metals.CodeLensProvider.findLenses(CodeLensProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1220)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1218)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:840)

2024.11.07 18:38:03 INFO  time: compiled root in 0.33s
2024.11.07 18:39:05 INFO  compiling root (1 scala source)
2024.11.07 18:39:05 INFO  time: compiled root in 0.26s
2024.11.07 18:39:06 INFO  compiling root (2 scala sources)
2024.11.07 18:39:06 INFO  time: compiled root in 0.41s
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:1:8: stale bloop error: object actor is not a member of package akka
import akka.actor.ActorSystem
       ^^^^^^^^^^
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:3:8: stale bloop error: object stream is not a member of package akka
import akka.stream.ActorMaterializer
       ^^^^^^^^^^^
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:9:25: stale bloop error: not found: value ActorSystem
  implicit val system = ActorSystem("hotel-booking-system")
                        ^^^^^^^^^^^
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:10:31: stale bloop error: not found: value ActorMaterializer
  implicit val materializer = ActorMaterializer()
                              ^^^^^^^^^^^^^^^^^
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:13:23: stale bloop error: Symbol 'type akka.actor.ExtensionId' is missing from the classpath.
This symbol is required by 'object akka.http.scaladsl.Http'.
Make sure that type ExtensionId is in your classpath and check for conflicting dependencies with `-Ylog-classpath`.
A full rebuild may help if 'Http.class' was compiled against an incompatible version of akka.actor.
  val bindingFuture = Http().bindAndHandle(RoomController.routes, "localhost", 8080)
                      ^^^^
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:9:16: stale bloop warning: Implicit definition should have explicit type [quickfixable]
  implicit val system = ActorSystem("hotel-booking-system")
               ^
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:10:16: stale bloop warning: Implicit definition should have explicit type [quickfixable]
  implicit val materializer = ActorMaterializer()
               ^
2024.11.07 18:39:51 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:11:16: stale bloop warning: Implicit definition should have explicit type [quickfixable]
  implicit val executionContext = system.dispatcher
               ^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:1:8: stale bloop error: object actor is not a member of package akka
import akka.actor.ActorSystem
       ^^^^^^^^^^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:3:8: stale bloop error: object stream is not a member of package akka
import akka.stream.ActorMaterializer
       ^^^^^^^^^^^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:9:25: stale bloop error: not found: value ActorSystem
  implicit val system = ActorSystem("hotel-booking-system")
                        ^^^^^^^^^^^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:10:31: stale bloop error: not found: value ActorMaterializer
  implicit val materializer = ActorMaterializer()
                              ^^^^^^^^^^^^^^^^^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:13:23: stale bloop error: Symbol 'type akka.actor.ExtensionId' is missing from the classpath.
This symbol is required by 'object akka.http.scaladsl.Http'.
Make sure that type ExtensionId is in your classpath and check for conflicting dependencies with `-Ylog-classpath`.
A full rebuild may help if 'Http.class' was compiled against an incompatible version of akka.actor.
  val bindingFuture = Http().bindAndHandle(RoomController.routes, "localhost", 8080)
                      ^^^^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:9:16: stale bloop warning: Implicit definition should have explicit type [quickfixable]
  implicit val system = ActorSystem("hotel-booking-system")
               ^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:10:16: stale bloop warning: Implicit definition should have explicit type [quickfixable]
  implicit val materializer = ActorMaterializer()
               ^
2024.11.07 18:39:54 INFO  file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/Main.scala:11:16: stale bloop warning: Implicit definition should have explicit type [quickfixable]
  implicit val executionContext = system.dispatcher
               ^
2024.11.07 18:41:49 INFO  skipping build import with status 'Installed'
2024.11.07 18:41:49 INFO  Disconnecting from Bloop session...
2024.11.07 18:41:49 INFO  Cancelling compilation on Bloop server
2024.11.07 18:41:49 INFO  Shut down connection with build server.
2024.11.07 18:41:49 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 18:41:49 INFO  Shut down connection with build server.
2024.11.07 18:41:49 INFO  Attempting to connect to the build server...
2024.11.07 18:41:49 INFO  Found a Bloop server running
2024.11.07 18:41:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:41:49 INFO  Attempting to connect to the build server...
2024.11.07 18:41:49 INFO  Found a Bloop server running
2024.11.07 18:41:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:41:50 INFO  time: Connected to build server in 1.03s
2024.11.07 18:41:50 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 18:41:50 INFO  running doctor check
2024.11.07 18:41:50 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 18:41:52 INFO  time: indexed workspace in 2.21s
2024.11.07 18:41:52 INFO  compiling root (2 scala sources)
2024.11.07 18:41:53 INFO  time: compiled hotel-bookinghotel-booking-build in 74ms
2024.11.07 18:41:52 INFO  Deduplicating compilation of root from bsp client 'Metals 1.4.0' (since 3.17s)
2024.11.07 18:41:52 INFO  compiling root (2 scala sources)
2024.11.07 18:41:52 INFO  time: compiled root in 0.32s
2024.11.07 18:41:54 INFO  compiling root (2 scala sources)
2024.11.07 18:41:54 INFO  time: compiled root in 0.34s
2024.11.07 18:41:56 INFO  skipping build import with status 'Installed'
2024.11.07 18:41:56 INFO  Disconnecting from Bloop session...
2024.11.07 18:41:56 INFO  Shut down connection with build server.
2024.11.07 18:41:56 INFO  Shut down connection with build server.
2024.11.07 18:41:56 INFO  Cancelling compilation on Bloop server
2024.11.07 18:41:56 INFO  Attempting to connect to the build server...
2024.11.07 18:41:56 INFO  Found a Bloop server running
2024.11.07 18:41:56 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 18:41:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:41:57 INFO  Attempting to connect to the build server...
2024.11.07 18:41:57 INFO  Found a Bloop server running
2024.11.07 18:41:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:41:57 INFO  time: Connected to build server in 0.91s
2024.11.07 18:41:57 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 18:41:56 INFO  running doctor check
2024.11.07 18:41:56 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 18:41:59 INFO  time: indexed workspace in 1.52s
2024.11.07 18:41:59 INFO  compiling root (2 scala sources)
2024.11.07 18:41:59 INFO  time: compiled hotel-bookinghotel-booking-build in 22ms
2024.11.07 18:41:59 INFO  time: compiled root in 0.25s
2024.11.07 18:42:06 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals7864821125206773195\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 18:42:08 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 18:42:08 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 18:42:09 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 18:42:09 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 18:42:09 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 18:42:11 INFO  compiling root (2 scala sources)
2024.11.07 18:42:11 INFO  time: compiled root in 0.7s
2024.11.07 18:42:13 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 18:42:13 INFO  [success] Total time: 3 s, completed 7 de nov de 2024 18:42:13
2024.11.07 18:42:16 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 18:42:16 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 18:42:35 INFO  [success] Generated .bloop\root-test.json
2024.11.07 18:42:35 INFO  [success] Generated .bloop\root.json
2024.11.07 18:42:35 INFO  [success] Total time: 18 s, completed 7 de nov de 2024 18:42:35
2024.11.07 18:42:35 INFO  time: ran 'sbt bloopInstall' in 28s
2024.11.07 18:42:35 INFO  Disconnecting from Bloop session...
2024.11.07 18:42:35 INFO  Shut down connection with build server.
2024.11.07 18:42:35 INFO  Shut down connection with build server.
2024.11.07 18:42:35 INFO  Attempting to connect to the build server...
2024.11.07 18:42:35 INFO  Found a Bloop server running
2024.11.07 18:42:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:42:35 INFO  Attempting to connect to the build server...
2024.11.07 18:42:35 INFO  Found a Bloop server running
2024.11.07 18:42:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 18:42:35 INFO  time: Connected to build server in 0.97s
2024.11.07 18:42:35 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 18:42:36 INFO  running doctor check
2024.11.07 18:42:36 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 18:42:38 INFO  time: indexed workspace in 2.56s
2024.11.07 18:42:38 INFO  compiling root (5 scala sources)
2024.11.07 18:42:40 WARN  1 deprecation (since 10.2.0)
2024.11.07 18:42:40 WARN  1 deprecation (since 2.6.0)
2024.11.07 18:42:40 WARN  2 deprecations in total; re-run with -deprecation for details
2024.11.07 18:42:40 INFO  compiling root-test (1 scala source)
2024.11.07 18:42:40 INFO  time: compiled root in 1.43s
2024.11.07 18:42:40 INFO  time: compiled root-test in 0.29s
2024.11.07 18:45:17 INFO  compiling root (1 scala source)
2024.11.07 18:45:17 INFO  time: compiled root in 0.65s
2024.11.07 18:45:19 INFO  compiling root (1 scala source)
2024.11.07 18:45:19 INFO  time: compiled root in 0.98s
2024.11.07 18:55:21 INFO  compiling root (1 scala source)
2024.11.07 18:55:21 INFO  time: compiled root in 0.22s
2024.11.07 18:55:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\Main.scala
2024.11.07 18:55:26 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\Main.scala
2024.11.07 18:55:26 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\Main.scala
2024.11.07 18:55:26 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\Main.scala
2024.11.07 18:55:26 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\Main.scala
2024.11.07 18:55:26 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\Main.scala
2024.11.07 18:55:27 INFO  time: compiled root in 13ms
2024.11.07 18:56:18 INFO  compiling root (1 scala source)
2024.11.07 18:56:18 INFO  time: compiled root in 0.19s
2024.11.07 18:56:54 INFO  compiling root (1 scala source)
2024.11.07 18:56:54 INFO  time: compiled root in 0.17s
2024.11.07 18:57:04 INFO  time: compiled root in 5ms
2024.11.07 18:57:36 INFO  compiling root (1 scala source)
2024.11.07 18:57:36 INFO  time: compiled root in 0.8s
2024.11.07 19:05:11 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals7728717586577130625\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 19:05:12 INFO  sbt thinks that server is already booting because of this exception:
2024.11.07 19:05:12 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-3648835929093046027_lock, error 5
2024.11.07 19:05:12 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.11.07 19:05:12 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.11.07 19:05:12 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:153)
2024.11.07 19:05:12 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:79)
2024.11.07 19:05:12 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:79)
2024.11.07 19:05:12 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:87)
2024.11.07 19:05:12 ERROR 	at sbt.xMain$.run(Main.scala:124)
2024.11.07 19:05:12 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.11.07 19:05:12 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2024.11.07 19:05:12 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.11.07 19:05:12 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
2024.11.07 19:05:12 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.11.07 19:05:12 ERROR 	at sbt.xMain.run(Main.scala:48)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.11.07 19:05:12 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.11.07 19:05:12 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-3648835929093046027_lock, error 5
2024.11.07 19:05:12 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.11.07 19:05:12 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.11.07 19:05:12 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.11.07 19:05:12 ERROR 	... 23 more
2024.11.07 19:05:12 INFO  time: ran 'sbt bloopInstall' in 1.76s
2024.11.07 19:05:12 ERROR sbt command failed: C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals7728717586577130625\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.11.07 19:05:12 INFO  Disconnecting from Bloop session...
2024.11.07 19:05:12 INFO  Shut down connection with build server.
2024.11.07 19:05:12 INFO  Shut down connection with build server.
2024.11.07 19:05:12 INFO  Attempting to connect to the build server...
2024.11.07 19:05:12 INFO  Found a Bloop server running
2024.11.07 19:05:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:05:12 INFO  Attempting to connect to the build server...
2024.11.07 19:05:12 INFO  Found a Bloop server running
2024.11.07 19:05:12 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:05:13 INFO  time: Connected to build server in 0.97s
2024.11.07 19:05:13 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 19:05:13 INFO  running doctor check
2024.11.07 19:05:13 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 19:05:15 INFO  time: indexed workspace in 2.03s
2024.11.07 19:05:43 INFO  skipping build import with status 'Installed'
2024.11.07 19:05:43 INFO  Disconnecting from Bloop session...
2024.11.07 19:05:43 INFO  Cancelling compilation on Bloop server
2024.11.07 19:05:43 INFO  Shut down connection with build server.
2024.11.07 19:05:43 INFO  Shut down connection with build server.
2024.11.07 19:05:43 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 19:05:43 INFO  Scala test classes not supported by server
2024.11.07 19:05:43 INFO  Attempting to connect to the build server...
2024.11.07 19:05:43 INFO  Found a Bloop server running
2024.11.07 19:05:43 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:05:43 INFO  Attempting to connect to the build server...
2024.11.07 19:05:43 INFO  Found a Bloop server running
2024.11.07 19:05:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:05:43 INFO  time: Connected to build server in 0.97s
2024.11.07 19:05:43 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 19:05:44 INFO  running doctor check
2024.11.07 19:05:44 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 19:05:45 INFO  time: indexed workspace in 1.6s
2024.11.07 19:05:45 INFO  time: compiled hotel-bookinghotel-booking-build in 54ms
2024.11.07 19:10:04 INFO  compiling root (1 scala source)
2024.11.07 19:10:04 INFO  time: compiled root in 0.13s
2024.11.07 19:10:07 INFO  time: compiled root in 3ms
2024.11.07 19:10:16 INFO  compiling root (1 scala source)
2024.11.07 19:10:16 INFO  time: compiled root in 0.13s
2024.11.07 19:10:22 INFO  skipping build import with status 'Installed'
2024.11.07 19:10:22 INFO  Disconnecting from Bloop session...
2024.11.07 19:10:22 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 19:10:22 INFO  Shut down connection with build server.
2024.11.07 19:10:22 INFO  Shut down connection with build server.
2024.11.07 19:10:22 INFO  Attempting to connect to the build server...
2024.11.07 19:10:22 INFO  Found a Bloop server running
2024.11.07 19:10:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:10:22 INFO  Attempting to connect to the build server...
2024.11.07 19:10:22 INFO  Found a Bloop server running
2024.11.07 19:10:23 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:10:22 INFO  time: Connected to build server in 0.91s
2024.11.07 19:10:22 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 19:10:23 INFO  running doctor check
2024.11.07 19:10:23 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 19:10:25 INFO  time: indexed workspace in 1.98s
2024.11.07 19:10:25 INFO  compiling root (1 scala source)
2024.11.07 19:10:25 INFO  time: compiled root in 0.15s
2024.11.07 19:10:25 INFO  compiling root (1 scala source)
2024.11.07 19:10:25 INFO  time: compiled root in 98ms
2024.11.07 19:10:27 INFO  skipping build import with status 'Installed'
2024.11.07 19:10:27 INFO  Disconnecting from Bloop session...
2024.11.07 19:10:27 INFO  Cancelling compilation on Bloop server
2024.11.07 19:10:27 INFO  Shut down connection with build server.
2024.11.07 19:10:27 INFO  Shut down connection with build server.
2024.11.07 19:10:27 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 19:10:27 INFO  Scala main classes not supported by server
2024.11.07 19:10:27 INFO  Attempting to connect to the build server...
2024.11.07 19:10:27 INFO  Found a Bloop server running
2024.11.07 19:10:27 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 19:10:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:10:28 INFO  Attempting to connect to the build server...
2024.11.07 19:10:28 INFO  Found a Bloop server running
2024.11.07 19:10:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:10:28 INFO  time: Connected to build server in 1s
2024.11.07 19:10:28 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 19:10:28 INFO  running doctor check
2024.11.07 19:10:28 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 19:10:30 INFO  time: indexed workspace in 1.62s
2024.11.07 19:10:30 INFO  compiling root (1 scala source)
2024.11.07 19:10:30 INFO  time: compiled hotel-bookinghotel-booking-build in 37ms
2024.11.07 19:10:30 INFO  time: compiled root in 0.12s
2024.11.07 19:11:00 INFO  time: compiled root in 3ms
2024.11.07 19:15:27 INFO  compiling root (1 scala source)
2024.11.07 19:15:27 INFO  time: compiled root in 0.51s
2024.11.07 19:15:34 INFO  compiling root (1 scala source)
2024.11.07 19:15:34 INFO  time: compiled root in 0.69s
2024.11.07 19:16:08 INFO  compiling root (1 scala source)
2024.11.07 19:16:08 INFO  time: compiled root in 0.29s
2024.11.07 19:16:28 INFO  compiling root (1 scala source)
2024.11.07 19:16:28 INFO  time: compiled root in 0.1s
2024.11.07 19:16:48 INFO  compiling root (2 scala sources)
2024.11.07 19:16:48 INFO  time: compiled root in 98ms
2024.11.07 19:18:40 INFO  compiling root (2 scala sources)
2024.11.07 19:18:40 INFO  time: compiled root in 0.12s
2024.11.07 19:19:24 INFO  compiling root (2 scala sources)
2024.11.07 19:19:24 INFO  time: compiled root in 0.11s
2024.11.07 19:20:56 INFO  skipping build import with status 'Installed'
2024.11.07 19:20:56 INFO  Disconnecting from Bloop session...
2024.11.07 19:20:56 INFO  Shut down connection with build server.
2024.11.07 19:20:56 INFO  Cancelling compilation on Bloop server
2024.11.07 19:20:56 INFO  Shut down connection with build server.
2024.11.07 19:20:56 INFO  Scala test classes not supported by server
2024.11.07 19:20:56 INFO  Attempting to connect to the build server...
2024.11.07 19:20:56 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 19:20:56 INFO  Found a Bloop server running
2024.11.07 19:20:56 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:20:56 INFO  Attempting to connect to the build server...
2024.11.07 19:20:56 INFO  Found a Bloop server running
2024.11.07 19:20:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:20:56 INFO  time: Connected to build server in 0.9s
2024.11.07 19:20:56 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 19:20:56 INFO  running doctor check
2024.11.07 19:20:56 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 19:20:58 INFO  compiling root (2 scala sources)
2024.11.07 19:20:58 INFO  time: compiled root in 0.13s
2024.11.07 19:20:59 INFO  time: indexed workspace in 2.08s
2024.11.07 19:20:59 INFO  compiling root (2 scala sources)
2024.11.07 19:20:59 INFO  time: compiled hotel-bookinghotel-booking-build in 45ms
2024.11.07 19:20:59 INFO  time: compiled root in 0.13s
2024.11.07 19:21:36 INFO  compiling root (2 scala sources)
2024.11.07 19:21:36 INFO  time: compiled root in 0.13s
2024.11.07 19:21:42 INFO  compiling root (2 scala sources)
2024.11.07 19:21:42 INFO  time: compiled root in 0.39s
2024.11.07 19:22:16 INFO  compiling root (2 scala sources)
2024.11.07 19:22:16 INFO  time: compiled root in 0.31s
2024.11.07 19:22:36 INFO  compiling root (2 scala sources)
2024.11.07 19:22:36 INFO  time: compiled root in 0.29s
2024.11.07 19:22:39 INFO  compiling root (2 scala sources)
2024.11.07 19:22:39 INFO  time: compiled root in 0.3s
2024.11.07 19:23:44 INFO  compiling root (3 scala sources)
2024.11.07 19:23:44 INFO  time: compiled root in 0.31s
2024.11.07 19:23:50 INFO  compiling root (3 scala sources)
2024.11.07 19:23:50 INFO  time: compiled root in 0.27s
2024.11.07 19:23:59 INFO  compiling root (3 scala sources)
2024.11.07 19:23:59 INFO  time: compiled root in 0.28s
2024.11.07 19:24:03 INFO  compiling root (3 scala sources)
2024.11.07 19:24:03 INFO  time: compiled root in 0.25s
2024.11.07 19:24:09 INFO  compiling root (3 scala sources)
2024.11.07 19:24:09 INFO  time: compiled root in 0.24s
2024.11.07 19:24:11 INFO  compiling root (3 scala sources)
2024.11.07 19:24:11 INFO  time: compiled root in 0.22s
2024.11.07 19:25:15 INFO  compiling root (3 scala sources)
2024.11.07 19:25:16 INFO  time: compiled root in 1.37s
2024.11.07 19:25:39 INFO  compiling root (1 scala source)
2024.11.07 19:25:39 INFO  time: compiled root in 0.65s
2024.11.07 19:27:08 INFO  compiling root (1 scala source)
2024.11.07 19:27:08 INFO  time: compiled root in 0.13s
2024.11.07 19:27:12 INFO  compiling root (1 scala source)
2024.11.07 19:27:12 INFO  time: compiled root in 0.59s
2024.11.07 19:27:17 INFO  compiling root (1 scala source)
2024.11.07 19:27:17 INFO  time: compiled root in 0.2s
2024.11.07 19:27:30 INFO  time: compiled root in 13ms
2024.11.07 19:27:38 INFO  compiling root (1 scala source)
2024.11.07 19:27:38 INFO  time: compiled root in 0.63s
2024.11.07 19:27:59 INFO  compiling root (1 scala source)
2024.11.07 19:27:59 INFO  time: compiled root in 0.64s
2024.11.07 19:29:18 INFO  compiling root (1 scala source)
2024.11.07 19:29:20 INFO  time: compiled root in 1.19s
2024.11.07 19:37:13 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals1724145175458795329\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 19:37:15 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 19:37:15 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 19:37:16 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 19:37:16 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 19:37:16 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 19:37:20 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 19:37:20 INFO  [success] Total time: 3 s, completed 7 de nov de 2024 19:37:20
2024.11.07 19:37:23 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 19:37:23 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 19:37:27 INFO  [success] Generated .bloop\root.json
2024.11.07 19:37:27 INFO  [success] Generated .bloop\root-test.json
2024.11.07 19:37:27 INFO  [success] Total time: 3 s, completed 7 de nov de 2024 19:37:27
2024.11.07 19:37:27 INFO  time: ran 'sbt bloopInstall' in 13s
2024.11.07 19:37:27 INFO  Disconnecting from Bloop session...
2024.11.07 19:37:27 INFO  Shut down connection with build server.
2024.11.07 19:37:27 INFO  Shut down connection with build server.
2024.11.07 19:37:27 INFO  Attempting to connect to the build server...
2024.11.07 19:37:27 INFO  Found a Bloop server running
2024.11.07 19:37:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:37:27 INFO  Attempting to connect to the build server...
2024.11.07 19:37:27 INFO  Found a Bloop server running
2024.11.07 19:37:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:37:28 INFO  time: Connected to build server in 0.97s
2024.11.07 19:37:28 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 19:37:28 INFO  running doctor check
2024.11.07 19:37:28 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 19:37:30 INFO  time: indexed workspace in 2.46s
2024.11.07 19:37:31 INFO  time: compiled root-test in 9ms
2024.11.07 19:42:19 INFO  compiling root (1 scala source)
2024.11.07 19:42:19 INFO  time: compiled root in 0.31s
2024.11.07 19:42:25 INFO  compiling root (1 scala source)
2024.11.07 19:42:25 INFO  time: compiled root in 0.14s
2024.11.07 19:43:16 INFO  compiling root (2 scala sources)
2024.11.07 19:43:16 INFO  time: compiled root in 0.19s
2024.11.07 19:43:23 INFO  compiling root (2 scala sources)
2024.11.07 19:43:23 INFO  time: compiled root in 0.18s
2024.11.07 19:45:09 INFO  compiling root (2 scala sources)
2024.11.07 19:45:09 INFO  time: compiled root in 0.15s
2024.11.07 19:45:11 INFO  compiling root (2 scala sources)
2024.11.07 19:45:11 INFO  time: compiled root in 0.14s
nov. 07, 2024 7:45:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.HOURS_PER_DAY;\nimport static java.time.LocalTime.MICROS_PER_DAY;\nimport static java.time.LocalTime.MILLIS_PER_DAY;\nimport static java.time.LocalTime.MINUTES_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_HOUR;\nimport static java.time.LocalTime.NANOS_PER_MINUTE;\nimport static java.time.LocalTime.NANOS_PER_SECOND;\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n * \u003cp\u003e\n * {@code LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be\n * stored in a {@code LocalDateTime}.\n * \u003cp\u003e\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDateTime\n        implements Temporal, TemporalAdjuster, ChronoLocalDateTime\u003cLocalDate\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDateTime}, \u0027-999999999-01-01T00:00:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final LocalDateTime MIN \u003d LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n    /**\n     * The maximum supported {@code LocalDateTime}, \u0027+999999999-12-31T23:59:59.999999999\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final LocalDateTime MAX \u003d LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 6207766400415563566L;\n\n    /**\n     * The date part.\n     */\n    private final LocalDate date;\n    /**\n     * The time part.\n     */\n    private final LocalTime time;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock and default time-zone, not null\n     */\n    public static LocalDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static LocalDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static LocalDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        ZoneOffset offset \u003d clock.getZone().getRules().getOffset(now);\n        return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a date and time.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @return the local date-time, not null\n     */\n    public static LocalDateTime of(LocalDate date, LocalTime time) {\n        Objects.requireNonNull(date, \"date\");\n        Objects.requireNonNull(time, \"time\");\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static LocalDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        return ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows the {@link ChronoField#INSTANT_SECONDS epoch-second} field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param epochSecond  the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param nanoOfSecond  the nanosecond within the second, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range,\n     *  or if the nano-of-second is invalid\n     */\n    public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) {\n        Objects.requireNonNull(offset, \"offset\");\n        NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        long localSecond \u003d epochSecond + offset.getTotalSeconds();  // overflow caught later\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        int secsOfDay \u003d Math.floorMod(localSecond, SECONDS_PER_DAY);\n        LocalDate date \u003d LocalDate.ofEpochDay(localEpochDay);\n        LocalTime time \u003d LocalTime.ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion extracts and combines the {@code LocalDate} and the\n     * {@code LocalTime} from the temporal object.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDateTime}\n     */\n    public static LocalDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof LocalDateTime) {\n            return (LocalDateTime) temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return ((ZonedDateTime) temporal).toLocalDateTime();\n        } else if (temporal instanceof OffsetDateTime) {\n            return ((OffsetDateTime) temporal).toLocalDateTime();\n        }\n        try {\n            LocalDate date \u003d LocalDate.from(temporal);\n            LocalTime time \u003d LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain LocalDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30\", not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param date  the date part of the date-time, validated not null\n     * @param time  the time part of the date-time, validated not null\n     */\n    private LocalDateTime(LocalDate date, LocalTime time) {\n        this.date \u003d date;\n        this.time \u003d time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param newDate  the date of the new date-time, not null\n     * @param newTime  the time of the new date-time, not null\n     * @return the date-time, not null\n     */\n    private LocalDateTime with(LocalDate newDate, LocalTime newTime) {\n        if (date \u003d\u003d newDate \u0026\u0026 time \u003d\u003d newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return f.isDateBased() || f.isTimeBased();\n        }\n        return field !\u003d null \u0026\u0026 field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDateTime.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.range(field) : date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH} which are too large to fit in\n     * an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.get(field) : date.get(field));\n        }\n        return ChronoLocalDateTime.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.getLong(field) : date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    @Override\n    public LocalDate toLocalDate() {\n        return date;\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return date.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return date.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return date.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return date.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return date.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return date.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    @Override\n    public LocalTime toLocalTime() {\n        return time;\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return time.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return time.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return time.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return time.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@code TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d localDateTime.with(date);\n     *  result \u003d localDateTime.with(time);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return with((LocalDate) adjuster, time);\n        } else if (adjuster instanceof LocalTime) {\n            return with(date, (LocalTime) adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return (LocalDateTime) adjuster;\n        }\n        return (LocalDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}\n     * or {@link LocalTime#with(TemporalField, long) LocalTime}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isTimeBased()) {\n                return with(date, time.with(field, newValue));\n            } else {\n                return with(date.with(field, newValue), time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return with(date.withYear(year), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDateTime withMonth(int month) {\n        return with(date.withMonth(month), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return with(date.withDayOfMonth(dayOfMonth), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return with(date.withDayOfYear(dayOfYear), time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return a {@code LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public LocalDateTime withHour(int hour) {\n        LocalTime newTime \u003d time.withHour(hour);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public LocalDateTime withMinute(int minute) {\n        LocalTime newTime \u003d time.withMinute(minute);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public LocalDateTime withSecond(int second) {\n        LocalTime newTime \u003d time.withSecond(second);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return a {@code LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public LocalDateTime withNano(int nanoOfSecond) {\n        LocalTime newTime \u003d time.withNano(nanoOfSecond);\n        return with(date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return a {@code LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public LocalDateTime truncatedTo(TemporalUnit unit) {\n        return with(date, time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return with(date.plus(periodToAdd), time);\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * Date units are added as per {@link LocalDate#plus(long, TemporalUnit)}.\n     * Time units are added as per {@link LocalTime#plus(long, TemporalUnit)} with\n     * any overflow in days added equivalent to using {@link #plusDays(long)}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case NANOS: return plusNanos(amountToAdd);\n                case MICROS: return plusDays(amountToAdd / MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n                case MILLIS: return plusDays(amountToAdd / MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n                case SECONDS: return plusSeconds(amountToAdd);\n                case MINUTES: return plusMinutes(amountToAdd);\n                case HOURS: return plusHours(amountToAdd);\n                case HALF_DAYS: return plusDays(amountToAdd / 256).plusHours((amountToAdd % 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return with(date.plus(amountToAdd, unit), time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusYears(long years) {\n        LocalDate newDate \u003d date.plusYears(years);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMonths(long months) {\n        LocalDate newDate \u003d date.plusMonths(months);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusWeeks(long weeks) {\n        LocalDate newDate \u003d date.plusWeeks(weeks);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusDays(long days) {\n        LocalDate newDate \u003d date.plusDays(days);\n        return with(newDate, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return with(date.minus(periodToSubtract), time);\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, -1);\n   }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified period added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param newDate  the new date to base the calculation on, not null\n     * @param hours  the hours to add, may be negative\n     * @param minutes the minutes to add, may be negative\n     * @param seconds the seconds to add, may be negative\n     * @param nanos the nanos to add, may be negative\n     * @param sign  the sign to determine add or subtract\n     * @return the combined result, not null\n     */\n    private LocalDateTime plusWithOverflow(LocalDate newDate, long hours, long minutes, long seconds, long nanos, int sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) \u003d\u003d 0) {\n            return with(newDate, time);\n        }\n        long totDays \u003d nanos / NANOS_PER_DAY +             //   max/24*60*60*1B\n                seconds / SECONDS_PER_DAY +                //   max/24*60*60\n                minutes / MINUTES_PER_DAY +                //   max/24*60\n                hours / HOURS_PER_DAY;                     //   max/24\n        totDays *\u003d sign;                                   // total max*0.4237...\n        long totNanos \u003d nanos % NANOS_PER_DAY +                    //   max  86400000000000\n                (seconds % SECONDS_PER_DAY) * NANOS_PER_SECOND +   //   max  86400000000000\n                (minutes % MINUTES_PER_DAY) * NANOS_PER_MINUTE +   //   max  86400000000000\n                (hours % HOURS_PER_DAY) * NANOS_PER_HOUR;          //   max  86400000000000\n        long curNoD \u003d time.toNanoOfDay();                       //   max  86400000000000\n        totNanos \u003d totNanos * sign + curNoD;                    // total 432000000000000\n        totDays +\u003d Math.floorDiv(totNanos, NANOS_PER_DAY);\n        long newNoD \u003d Math.floorMod(totNanos, NANOS_PER_DAY);\n        LocalTime newTime \u003d (newNoD \u003d\u003d curNoD ? time : LocalTime.ofNanoOfDay(newNoD));\n        return with(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override  // override for Javadoc\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) date;\n        }\n        return ChronoLocalDateTime.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDateTime.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDateTime} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDateTime end \u003d LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                long amount \u003d date.daysUntil(end.date);\n                if (amount \u003d\u003d 0) {\n                    return time.until(end.time, unit);\n                }\n                long timePart \u003d end.time.toNanoOfDay() - time.toNanoOfDay();\n                if (amount \u003e 0) {\n                    amount--;  // safe\n                    timePart +\u003d NANOS_PER_DAY;  // safe\n                } else {\n                    amount++;  // safe\n                    timePart -\u003d NANOS_PER_DAY;  // safe\n                }\n                switch ((ChronoUnit) unit) {\n                    case NANOS:\n                        amount \u003d Math.multiplyExact(amount, NANOS_PER_DAY);\n                        break;\n                    case MICROS:\n                        amount \u003d Math.multiplyExact(amount, MICROS_PER_DAY);\n                        timePart \u003d timePart / 1000;\n                        break;\n                    case MILLIS:\n                        amount \u003d Math.multiplyExact(amount, MILLIS_PER_DAY);\n                        timePart \u003d timePart / 1_000_000;\n                        break;\n                    case SECONDS:\n                        amount \u003d Math.multiplyExact(amount, SECONDS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_SECOND;\n                        break;\n                    case MINUTES:\n                        amount \u003d Math.multiplyExact(amount, MINUTES_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_MINUTE;\n                        break;\n                    case HOURS:\n                        amount \u003d Math.multiplyExact(amount, HOURS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_HOUR;\n                        break;\n                    case HALF_DAYS:\n                        amount \u003d Math.multiplyExact(amount, 2);\n                        timePart \u003d timePart / (NANOS_PER_HOUR * 12);\n                        break;\n                }\n                return Math.addExact(amount, timePart);\n            }\n            LocalDate endDate \u003d end.date;\n            if (endDate.isAfter(date) \u0026\u0026 end.time.isBefore(time)) {\n                endDate \u003d endDate.minusDays(1);\n            } else if (endDate.isBefore(date) \u0026\u0026 end.time.isAfter(time)) {\n                endDate \u003d endDate.plusDays(1);\n            }\n            return date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param offset  the offset to combine with, not null\n     * @return the offset date-time formed from this date-time and the specified offset, not null\n     */\n    public OffsetDateTime atOffset(ZoneOffset offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * \u003cp\u003e\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *\u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    @Override\n    public ZonedDateTime atZone(ZoneId zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the date-times being compared are instances of {@code LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other);\n        }\n        return ChronoLocalDateTime.super.compareTo(other);\n    }\n\n    private int compareTo0(LocalDateTime other) {\n        int cmp \u003d date.compareTo0(other.toLocalDate());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is after the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003e 0;\n        }\n        return ChronoLocalDateTime.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is before the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003c 0;\n        }\n        return ChronoLocalDateTime.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is equal to the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDateTime.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * Compares this {@code LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@code LocalDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDateTime) {\n            LocalDateTime other \u003d (LocalDateTime) obj;\n            return date.equals(other.date) \u0026\u0026 time.equals(other.time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return date.hashCode() ^ time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSS}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return date.toString() + \u0027T\u0027 + time.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(5);  // identifies a LocalDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDate\"\u003edate\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalTime\"\u003etime\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        date.writeExternal(out);\n        time.writeExternal(out);\n    }\n\n    static LocalDateTime readExternal(DataInput in) throws IOException {\n        LocalDate date \u003d LocalDate.readExternal(in);\n        LocalTime time \u003d LocalTime.readExternal(in);\n        return LocalDateTime.of(date, time);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

nov. 07, 2024 7:45:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.11.07 19:46:14 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals2016460414009313811\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 19:46:16 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 19:46:16 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 19:46:17 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 19:46:18 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 19:46:18 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 19:46:20 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 19:46:20 INFO  [success] Total time: 2 s, completed 7 de nov de 2024 19:46:21
2024.11.07 19:46:24 INFO  compiling root (2 scala sources)
2024.11.07 19:46:24 INFO  time: compiled root in 0.29s
2024.11.07 19:46:24 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 19:46:24 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 19:46:29 INFO  [success] Generated .bloop\root-test.json
2024.11.07 19:46:29 INFO  [success] Generated .bloop\root.json
2024.11.07 19:46:29 INFO  [success] Total time: 5 s, completed 7 de nov de 2024 19:46:29
2024.11.07 19:46:29 INFO  time: ran 'sbt bloopInstall' in 15s
2024.11.07 19:46:29 INFO  Disconnecting from Bloop session...
2024.11.07 19:46:29 INFO  Shut down connection with build server.
2024.11.07 19:46:29 INFO  Shut down connection with build server.
2024.11.07 19:46:29 INFO  Attempting to connect to the build server...
2024.11.07 19:46:29 INFO  Found a Bloop server running
2024.11.07 19:46:29 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:46:29 INFO  Attempting to connect to the build server...
2024.11.07 19:46:29 INFO  Found a Bloop server running
2024.11.07 19:46:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 19:46:29 INFO  time: Connected to build server in 0.99s
2024.11.07 19:46:29 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 19:46:30 INFO  running doctor check
2024.11.07 19:46:30 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 19:46:32 INFO  time: indexed workspace in 2.52s
2024.11.07 19:46:33 INFO  compiling root (2 scala sources)
2024.11.07 19:46:33 INFO  time: compiled root in 0.4s
2024.11.07 19:51:17 INFO  compiling root (2 scala sources)
2024.11.07 19:51:17 INFO  time: compiled root in 0.29s
2024.11.07 19:51:25 INFO  compiling root (2 scala sources)
2024.11.07 19:51:25 INFO  time: compiled root in 0.25s
2024.11.07 19:51:45 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:840)

2024.11.07 19:51:45 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:840)

2024.11.07 19:51:45 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:840)

2024.11.07 19:51:45 WARN  Could not find 'result' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
nov. 07, 2024 7:51:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1905
nov. 07, 2024 7:51:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1907
2024.11.07 19:52:02 ERROR searching for `.` failed
java.lang.RuntimeException: invalid symbol format
.
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:211)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:840)

2024.11.07 19:52:02 ERROR searching for `#` failed
java.lang.RuntimeException: invalid symbol format
#
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:214)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:840)

2024.11.07 19:52:02 ERROR searching for `().` failed
java.lang.RuntimeException: invalid symbol format
().
^
	at scala.sys.package$.error(package.scala:27)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.fail(Scala.scala:164)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.readChar(Scala.scala:176)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseValue(Scala.scala:192)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.parseDescriptor(Scala.scala:209)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser.entryPoint(Scala.scala:232)
	at scala.meta.internal.semanticdb.Scala$DescriptorParser$.apply(Scala.scala:240)
	at scala.meta.internal.semanticdb.Scala$ScalaSymbolOps$.owner$extension(Scala.scala:80)
	at scala.meta.internal.mtags.Symbol.toplevel(Symbol.scala:50)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:200)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.FallbackDefinitionProvider.findInIndex$1(FallbackDefinitionProvider.scala:125)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$15(FallbackDefinitionProvider.scala:132)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$3(FallbackDefinitionProvider.scala:131)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$2(FallbackDefinitionProvider.scala:43)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.$anonfun$search$1(FallbackDefinitionProvider.scala:40)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.FallbackDefinitionProvider.search(FallbackDefinitionProvider.scala:39)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$3(DefinitionProvider.scala:120)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definition$2(DefinitionProvider.scala:120)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:840)

2024.11.07 19:52:02 WARN  Could not find 'result' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.07 19:52:35 INFO  compiling root (2 scala sources)
2024.11.07 19:52:35 INFO  time: compiled root in 0.3s
2024.11.07 19:55:45 INFO  compiling root (2 scala sources)
2024.11.07 19:55:45 INFO  time: compiled root in 0.11s
2024.11.07 19:56:28 INFO  compiling root (2 scala sources)
2024.11.07 19:56:29 INFO  time: compiled root in 1.09s
2024.11.07 19:56:29 INFO  compiling root (2 scala sources)
2024.11.07 19:56:29 INFO  time: compiled root in 0.32s
2024.11.07 19:56:32 INFO  compiling root (2 scala sources)
2024.11.07 19:56:32 INFO  time: compiled root in 0.89s
2024.11.07 19:56:32 INFO  compiling root (2 scala sources)
2024.11.07 19:56:33 INFO  time: compiled root in 0.33s
2024.11.07 19:56:36 INFO  compiling root (2 scala sources)
2024.11.07 19:56:36 INFO  time: compiled root in 0.92s
2024.11.07 19:56:36 INFO  compiling root (2 scala sources)
2024.11.07 19:56:37 INFO  time: compiled root in 0.31s
2024.11.07 19:58:02 INFO  compiling root (3 scala sources)
2024.11.07 19:58:02 INFO  time: compiled root in 0.12s
2024.11.07 19:58:09 INFO  compiling root (3 scala sources)
2024.11.07 19:58:09 INFO  time: compiled root in 0.12s
2024.11.07 19:58:11 INFO  compiling root (3 scala sources)
2024.11.07 19:58:11 INFO  time: compiled root in 0.12s
2024.11.07 19:58:19 WARN  Could not find semantic tokens for: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/models/ReservationTable.scala
2024.11.07 19:58:27 INFO  compiling root (3 scala sources)
2024.11.07 19:58:27 INFO  time: compiled root in 0.96s
2024.11.07 19:58:27 INFO  compiling root (2 scala sources)
2024.11.07 19:58:28 INFO  time: compiled root in 0.26s
2024.11.07 19:58:42 INFO  compiling root (3 scala sources)
2024.11.07 19:58:42 INFO  time: compiled root in 0.11s
2024.11.07 19:58:47 INFO  compiling root (3 scala sources)
2024.11.07 19:58:47 INFO  time: compiled root in 0.11s
2024.11.07 19:59:09 INFO  compiling root (3 scala sources)
2024.11.07 19:59:09 INFO  time: compiled root in 0.9s
2024.11.07 19:59:09 INFO  compiling root (2 scala sources)
2024.11.07 19:59:10 INFO  time: compiled root in 0.24s
2024.11.07 19:59:21 INFO  compiling root (3 scala sources)
2024.11.07 19:59:21 INFO  time: compiled root in 0.13s
2024.11.07 20:00:41 INFO  compiling root (3 scala sources)
2024.11.07 20:00:41 INFO  time: compiled root in 0.11s
2024.11.07 20:01:33 INFO  compiling root (3 scala sources)
2024.11.07 20:01:33 INFO  time: compiled root in 0.12s
2024.11.07 20:01:38 INFO  compiling root (3 scala sources)
2024.11.07 20:01:39 INFO  time: compiled root in 1.01s
2024.11.07 20:01:39 INFO  compiling root (2 scala sources)
2024.11.07 20:01:39 INFO  time: compiled root in 0.24s
2024.11.07 20:02:38 INFO  compiling root (3 scala sources)
2024.11.07 20:02:39 INFO  time: compiled root in 1.12s
2024.11.07 20:02:39 INFO  compiling root (2 scala sources)
2024.11.07 20:02:39 INFO  time: compiled root in 0.3s
2024.11.07 20:02:43 INFO  compiling root (3 scala sources)
2024.11.07 20:02:44 INFO  time: compiled root in 1.16s
2024.11.07 20:02:44 INFO  compiling root (2 scala sources)
2024.11.07 20:02:44 INFO  time: compiled root in 0.26s
2024.11.07 20:02:49 INFO  compiling root (3 scala sources)
2024.11.07 20:02:49 INFO  time: compiled root in 0.2s
2024.11.07 20:03:56 INFO  compiling root (3 scala sources)
2024.11.07 20:03:56 INFO  time: compiled root in 0.22s
2024.11.07 20:03:58 INFO  compiling root (3 scala sources)
2024.11.07 20:03:58 INFO  time: compiled root in 0.92s
2024.11.07 20:03:58 INFO  compiling root (2 scala sources)
2024.11.07 20:04:00 INFO  time: compiled root in 0.27s
2024.11.07 20:04:21 INFO  compiling root (3 scala sources)
2024.11.07 20:04:21 INFO  time: compiled root in 0.86s
2024.11.07 20:04:21 INFO  compiling root (2 scala sources)
2024.11.07 20:04:22 INFO  time: compiled root in 0.18s
2024.11.07 20:04:25 INFO  compiling root (3 scala sources)
2024.11.07 20:04:25 INFO  time: compiled root in 0.97s
2024.11.07 20:04:25 INFO  compiling root (2 scala sources)
2024.11.07 20:04:26 INFO  time: compiled root in 0.23s
2024.11.07 20:04:27 INFO  compiling root (3 scala sources)
2024.11.07 20:04:27 INFO  time: compiled root in 0.82s
2024.11.07 20:04:27 INFO  compiling root (2 scala sources)
2024.11.07 20:04:28 INFO  time: compiled root in 0.19s
2024.11.07 20:05:49 INFO  compiling root (4 scala sources)
2024.11.07 20:05:50 INFO  time: compiled root in 1.02s
2024.11.07 20:05:50 INFO  compiling root (2 scala sources)
2024.11.07 20:05:50 INFO  time: compiled root in 0.18s
2024.11.07 20:06:00 INFO  compiling root (4 scala sources)
2024.11.07 20:06:00 INFO  time: compiled root in 0.91s
2024.11.07 20:06:00 INFO  compiling root (2 scala sources)
2024.11.07 20:06:01 INFO  time: compiled root in 0.18s
2024.11.07 20:06:10 INFO  compiling root (4 scala sources)
2024.11.07 20:06:10 INFO  time: compiled root in 0.96s
2024.11.07 20:06:10 INFO  compiling root (2 scala sources)
2024.11.07 20:06:11 INFO  time: compiled root in 0.19s
2024.11.07 20:06:23 INFO  compiling root (11 scala sources)
2024.11.07 20:06:23 INFO  time: compiled root in 0.12s
2024.11.07 20:06:32 INFO  compiling root (11 scala sources)
2024.11.07 20:06:32 INFO  time: compiled root in 0.11s
2024.11.07 20:06:35 INFO  compiling root (11 scala sources)
2024.11.07 20:06:35 INFO  time: compiled root in 0.11s
nov. 07, 2024 8:07:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.HOURS_PER_DAY;\nimport static java.time.LocalTime.MICROS_PER_DAY;\nimport static java.time.LocalTime.MILLIS_PER_DAY;\nimport static java.time.LocalTime.MINUTES_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_HOUR;\nimport static java.time.LocalTime.NANOS_PER_MINUTE;\nimport static java.time.LocalTime.NANOS_PER_SECOND;\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n * \u003cp\u003e\n * {@code LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be\n * stored in a {@code LocalDateTime}.\n * \u003cp\u003e\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDateTime\n        implements Temporal, TemporalAdjuster, ChronoLocalDateTime\u003cLocalDate\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDateTime}, \u0027-999999999-01-01T00:00:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final LocalDateTime MIN \u003d LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n    /**\n     * The maximum supported {@code LocalDateTime}, \u0027+999999999-12-31T23:59:59.999999999\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final LocalDateTime MAX \u003d LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 6207766400415563566L;\n\n    /**\n     * The date part.\n     */\n    private final LocalDate date;\n    /**\n     * The time part.\n     */\n    private final LocalTime time;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock and default time-zone, not null\n     */\n    public static LocalDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static LocalDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static LocalDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        ZoneOffset offset \u003d clock.getZone().getRules().getOffset(now);\n        return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a date and time.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @return the local date-time, not null\n     */\n    public static LocalDateTime of(LocalDate date, LocalTime time) {\n        Objects.requireNonNull(date, \"date\");\n        Objects.requireNonNull(time, \"time\");\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static LocalDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        return ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows the {@link ChronoField#INSTANT_SECONDS epoch-second} field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param epochSecond  the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param nanoOfSecond  the nanosecond within the second, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range,\n     *  or if the nano-of-second is invalid\n     */\n    public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) {\n        Objects.requireNonNull(offset, \"offset\");\n        NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        long localSecond \u003d epochSecond + offset.getTotalSeconds();  // overflow caught later\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        int secsOfDay \u003d Math.floorMod(localSecond, SECONDS_PER_DAY);\n        LocalDate date \u003d LocalDate.ofEpochDay(localEpochDay);\n        LocalTime time \u003d LocalTime.ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion extracts and combines the {@code LocalDate} and the\n     * {@code LocalTime} from the temporal object.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDateTime}\n     */\n    public static LocalDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof LocalDateTime) {\n            return (LocalDateTime) temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return ((ZonedDateTime) temporal).toLocalDateTime();\n        } else if (temporal instanceof OffsetDateTime) {\n            return ((OffsetDateTime) temporal).toLocalDateTime();\n        }\n        try {\n            LocalDate date \u003d LocalDate.from(temporal);\n            LocalTime time \u003d LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain LocalDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30\", not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param date  the date part of the date-time, validated not null\n     * @param time  the time part of the date-time, validated not null\n     */\n    private LocalDateTime(LocalDate date, LocalTime time) {\n        this.date \u003d date;\n        this.time \u003d time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param newDate  the date of the new date-time, not null\n     * @param newTime  the time of the new date-time, not null\n     * @return the date-time, not null\n     */\n    private LocalDateTime with(LocalDate newDate, LocalTime newTime) {\n        if (date \u003d\u003d newDate \u0026\u0026 time \u003d\u003d newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return f.isDateBased() || f.isTimeBased();\n        }\n        return field !\u003d null \u0026\u0026 field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDateTime.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.range(field) : date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH} which are too large to fit in\n     * an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.get(field) : date.get(field));\n        }\n        return ChronoLocalDateTime.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.getLong(field) : date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    @Override\n    public LocalDate toLocalDate() {\n        return date;\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return date.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return date.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return date.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return date.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return date.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return date.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    @Override\n    public LocalTime toLocalTime() {\n        return time;\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return time.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return time.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return time.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return time.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@code TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d localDateTime.with(date);\n     *  result \u003d localDateTime.with(time);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return with((LocalDate) adjuster, time);\n        } else if (adjuster instanceof LocalTime) {\n            return with(date, (LocalTime) adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return (LocalDateTime) adjuster;\n        }\n        return (LocalDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}\n     * or {@link LocalTime#with(TemporalField, long) LocalTime}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isTimeBased()) {\n                return with(date, time.with(field, newValue));\n            } else {\n                return with(date.with(field, newValue), time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return with(date.withYear(year), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDateTime withMonth(int month) {\n        return with(date.withMonth(month), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return with(date.withDayOfMonth(dayOfMonth), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return with(date.withDayOfYear(dayOfYear), time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return a {@code LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public LocalDateTime withHour(int hour) {\n        LocalTime newTime \u003d time.withHour(hour);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public LocalDateTime withMinute(int minute) {\n        LocalTime newTime \u003d time.withMinute(minute);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public LocalDateTime withSecond(int second) {\n        LocalTime newTime \u003d time.withSecond(second);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return a {@code LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public LocalDateTime withNano(int nanoOfSecond) {\n        LocalTime newTime \u003d time.withNano(nanoOfSecond);\n        return with(date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return a {@code LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public LocalDateTime truncatedTo(TemporalUnit unit) {\n        return with(date, time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return with(date.plus(periodToAdd), time);\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * Date units are added as per {@link LocalDate#plus(long, TemporalUnit)}.\n     * Time units are added as per {@link LocalTime#plus(long, TemporalUnit)} with\n     * any overflow in days added equivalent to using {@link #plusDays(long)}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case NANOS: return plusNanos(amountToAdd);\n                case MICROS: return plusDays(amountToAdd / MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n                case MILLIS: return plusDays(amountToAdd / MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n                case SECONDS: return plusSeconds(amountToAdd);\n                case MINUTES: return plusMinutes(amountToAdd);\n                case HOURS: return plusHours(amountToAdd);\n                case HALF_DAYS: return plusDays(amountToAdd / 256).plusHours((amountToAdd % 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return with(date.plus(amountToAdd, unit), time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusYears(long years) {\n        LocalDate newDate \u003d date.plusYears(years);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMonths(long months) {\n        LocalDate newDate \u003d date.plusMonths(months);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusWeeks(long weeks) {\n        LocalDate newDate \u003d date.plusWeeks(weeks);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusDays(long days) {\n        LocalDate newDate \u003d date.plusDays(days);\n        return with(newDate, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return with(date.minus(periodToSubtract), time);\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, -1);\n   }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified period added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param newDate  the new date to base the calculation on, not null\n     * @param hours  the hours to add, may be negative\n     * @param minutes the minutes to add, may be negative\n     * @param seconds the seconds to add, may be negative\n     * @param nanos the nanos to add, may be negative\n     * @param sign  the sign to determine add or subtract\n     * @return the combined result, not null\n     */\n    private LocalDateTime plusWithOverflow(LocalDate newDate, long hours, long minutes, long seconds, long nanos, int sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) \u003d\u003d 0) {\n            return with(newDate, time);\n        }\n        long totDays \u003d nanos / NANOS_PER_DAY +             //   max/24*60*60*1B\n                seconds / SECONDS_PER_DAY +                //   max/24*60*60\n                minutes / MINUTES_PER_DAY +                //   max/24*60\n                hours / HOURS_PER_DAY;                     //   max/24\n        totDays *\u003d sign;                                   // total max*0.4237...\n        long totNanos \u003d nanos % NANOS_PER_DAY +                    //   max  86400000000000\n                (seconds % SECONDS_PER_DAY) * NANOS_PER_SECOND +   //   max  86400000000000\n                (minutes % MINUTES_PER_DAY) * NANOS_PER_MINUTE +   //   max  86400000000000\n                (hours % HOURS_PER_DAY) * NANOS_PER_HOUR;          //   max  86400000000000\n        long curNoD \u003d time.toNanoOfDay();                       //   max  86400000000000\n        totNanos \u003d totNanos * sign + curNoD;                    // total 432000000000000\n        totDays +\u003d Math.floorDiv(totNanos, NANOS_PER_DAY);\n        long newNoD \u003d Math.floorMod(totNanos, NANOS_PER_DAY);\n        LocalTime newTime \u003d (newNoD \u003d\u003d curNoD ? time : LocalTime.ofNanoOfDay(newNoD));\n        return with(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override  // override for Javadoc\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) date;\n        }\n        return ChronoLocalDateTime.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDateTime.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDateTime} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDateTime end \u003d LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                long amount \u003d date.daysUntil(end.date);\n                if (amount \u003d\u003d 0) {\n                    return time.until(end.time, unit);\n                }\n                long timePart \u003d end.time.toNanoOfDay() - time.toNanoOfDay();\n                if (amount \u003e 0) {\n                    amount--;  // safe\n                    timePart +\u003d NANOS_PER_DAY;  // safe\n                } else {\n                    amount++;  // safe\n                    timePart -\u003d NANOS_PER_DAY;  // safe\n                }\n                switch ((ChronoUnit) unit) {\n                    case NANOS:\n                        amount \u003d Math.multiplyExact(amount, NANOS_PER_DAY);\n                        break;\n                    case MICROS:\n                        amount \u003d Math.multiplyExact(amount, MICROS_PER_DAY);\n                        timePart \u003d timePart / 1000;\n                        break;\n                    case MILLIS:\n                        amount \u003d Math.multiplyExact(amount, MILLIS_PER_DAY);\n                        timePart \u003d timePart / 1_000_000;\n                        break;\n                    case SECONDS:\n                        amount \u003d Math.multiplyExact(amount, SECONDS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_SECOND;\n                        break;\n                    case MINUTES:\n                        amount \u003d Math.multiplyExact(amount, MINUTES_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_MINUTE;\n                        break;\n                    case HOURS:\n                        amount \u003d Math.multiplyExact(amount, HOURS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_HOUR;\n                        break;\n                    case HALF_DAYS:\n                        amount \u003d Math.multiplyExact(amount, 2);\n                        timePart \u003d timePart / (NANOS_PER_HOUR * 12);\n                        break;\n                }\n                return Math.addExact(amount, timePart);\n            }\n            LocalDate endDate \u003d end.date;\n            if (endDate.isAfter(date) \u0026\u0026 end.time.isBefore(time)) {\n                endDate \u003d endDate.minusDays(1);\n            } else if (endDate.isBefore(date) \u0026\u0026 end.time.isAfter(time)) {\n                endDate \u003d endDate.plusDays(1);\n            }\n            return date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param offset  the offset to combine with, not null\n     * @return the offset date-time formed from this date-time and the specified offset, not null\n     */\n    public OffsetDateTime atOffset(ZoneOffset offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * \u003cp\u003e\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *\u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    @Override\n    public ZonedDateTime atZone(ZoneId zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the date-times being compared are instances of {@code LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other);\n        }\n        return ChronoLocalDateTime.super.compareTo(other);\n    }\n\n    private int compareTo0(LocalDateTime other) {\n        int cmp \u003d date.compareTo0(other.toLocalDate());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is after the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003e 0;\n        }\n        return ChronoLocalDateTime.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is before the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003c 0;\n        }\n        return ChronoLocalDateTime.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is equal to the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDateTime.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * Compares this {@code LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@code LocalDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDateTime) {\n            LocalDateTime other \u003d (LocalDateTime) obj;\n            return date.equals(other.date) \u0026\u0026 time.equals(other.time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return date.hashCode() ^ time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSS}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return date.toString() + \u0027T\u0027 + time.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(5);  // identifies a LocalDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDate\"\u003edate\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalTime\"\u003etime\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        date.writeExternal(out);\n        time.writeExternal(out);\n    }\n\n    static LocalDateTime readExternal(DataInput in) throws IOException {\n        LocalDate date \u003d LocalDate.readExternal(in);\n        LocalTime time \u003d LocalTime.readExternal(in);\n        return LocalDateTime.of(date, time);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor25.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

nov. 07, 2024 8:07:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.11.07 20:07:44 INFO  compiling root (10 scala sources)
2024.11.07 20:07:45 INFO  time: compiled root in 1.64s
2024.11.07 20:42:13 INFO  compiling root (1 scala source)
2024.11.07 20:42:14 INFO  time: compiled root in 1.16s
2024.11.07 20:42:14 INFO  compiling root (1 scala source)
2024.11.07 20:42:14 INFO  time: compiled root in 0.12s
2024.11.07 20:42:14 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\ReservationController.scala
2024.11.07 20:42:29 INFO  compiling root (2 scala sources)
2024.11.07 20:42:29 INFO  time: compiled root in 0.21s
2024.11.07 20:42:33 INFO  compiling root (1 scala source)
2024.11.07 20:42:33 INFO  time: compiled root in 0.86s
2024.11.07 20:42:33 INFO  compiling root (1 scala source)
2024.11.07 20:42:33 INFO  time: compiled root in 86ms
2024.11.07 20:42:35 INFO  compiling root (1 scala source)
2024.11.07 20:42:35 INFO  time: compiled root in 0.91s
2024.11.07 20:42:35 INFO  compiling root (1 scala source)
2024.11.07 20:42:36 INFO  time: compiled root in 89ms
2024.11.07 20:42:37 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\ReservationController.scala
2024.11.07 20:43:47 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\ReservationController.scala
2024.11.07 20:43:47 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\ReservationController.scala
2024.11.07 20:43:51 INFO  time: compiled root in 3ms
2024.11.07 20:44:08 INFO  compiling root (1 scala source)
2024.11.07 20:44:08 INFO  time: compiled root in 0.91s
2024.11.07 20:44:08 INFO  compiling root (1 scala source)
2024.11.07 20:44:08 INFO  time: compiled root in 87ms
2024.11.07 20:46:08 INFO  compiling root (1 scala source)
2024.11.07 20:46:08 INFO  time: compiled root in 0.99s
2024.11.07 20:46:11 INFO  compiling root (1 scala source)
2024.11.07 20:46:11 INFO  time: compiled root in 0.8s
2024.11.07 20:48:13 INFO  compiling root (1 scala source)
2024.11.07 20:48:13 INFO  time: compiled root in 0.34s
2024.11.07 20:48:30 INFO  compiling root (1 scala source)
2024.11.07 20:48:30 INFO  time: compiled root in 0.36s
2024.11.07 20:48:42 INFO  compiling root (1 scala source)
2024.11.07 20:48:42 INFO  time: compiled root in 0.25s
2024.11.07 20:48:47 INFO  compiling root (2 scala sources)
2024.11.07 20:48:47 INFO  time: compiled root in 0.3s
2024.11.07 20:49:50 INFO  compiling root (3 scala sources)
2024.11.07 20:49:50 INFO  time: compiled root in 0.11s
2024.11.07 20:49:57 INFO  compiling root (3 scala sources)
2024.11.07 20:49:57 INFO  time: compiled root in 0.11s
2024.11.07 20:50:17 INFO  compiling root (3 scala sources)
2024.11.07 20:50:17 INFO  time: compiled root in 0.12s
2024.11.07 20:50:19 INFO  compiling root (3 scala sources)
2024.11.07 20:50:19 INFO  time: compiled root in 0.1s
nov. 07, 2024 8:51:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3669
nov. 07, 2024 8:51:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3670
nov. 07, 2024 8:51:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3673
nov. 07, 2024 8:51:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3677
nov. 07, 2024 8:51:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3686
nov. 07, 2024 8:51:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3687
2024.11.07 20:51:12 INFO  compiling root (3 scala sources)
2024.11.07 20:51:12 INFO  time: compiled root in 0.35s
nov. 07, 2024 8:51:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.HOURS_PER_DAY;\nimport static java.time.LocalTime.MICROS_PER_DAY;\nimport static java.time.LocalTime.MILLIS_PER_DAY;\nimport static java.time.LocalTime.MINUTES_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_HOUR;\nimport static java.time.LocalTime.NANOS_PER_MINUTE;\nimport static java.time.LocalTime.NANOS_PER_SECOND;\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n * \u003cp\u003e\n * {@code LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be\n * stored in a {@code LocalDateTime}.\n * \u003cp\u003e\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDateTime\n        implements Temporal, TemporalAdjuster, ChronoLocalDateTime\u003cLocalDate\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDateTime}, \u0027-999999999-01-01T00:00:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final LocalDateTime MIN \u003d LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n    /**\n     * The maximum supported {@code LocalDateTime}, \u0027+999999999-12-31T23:59:59.999999999\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final LocalDateTime MAX \u003d LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 6207766400415563566L;\n\n    /**\n     * The date part.\n     */\n    private final LocalDate date;\n    /**\n     * The time part.\n     */\n    private final LocalTime time;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock and default time-zone, not null\n     */\n    public static LocalDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static LocalDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static LocalDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        ZoneOffset offset \u003d clock.getZone().getRules().getOffset(now);\n        return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a date and time.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @return the local date-time, not null\n     */\n    public static LocalDateTime of(LocalDate date, LocalTime time) {\n        Objects.requireNonNull(date, \"date\");\n        Objects.requireNonNull(time, \"time\");\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static LocalDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        return ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows the {@link ChronoField#INSTANT_SECONDS epoch-second} field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param epochSecond  the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param nanoOfSecond  the nanosecond within the second, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range,\n     *  or if the nano-of-second is invalid\n     */\n    public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) {\n        Objects.requireNonNull(offset, \"offset\");\n        NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        long localSecond \u003d epochSecond + offset.getTotalSeconds();  // overflow caught later\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        int secsOfDay \u003d Math.floorMod(localSecond, SECONDS_PER_DAY);\n        LocalDate date \u003d LocalDate.ofEpochDay(localEpochDay);\n        LocalTime time \u003d LocalTime.ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion extracts and combines the {@code LocalDate} and the\n     * {@code LocalTime} from the temporal object.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDateTime}\n     */\n    public static LocalDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof LocalDateTime) {\n            return (LocalDateTime) temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return ((ZonedDateTime) temporal).toLocalDateTime();\n        } else if (temporal instanceof OffsetDateTime) {\n            return ((OffsetDateTime) temporal).toLocalDateTime();\n        }\n        try {\n            LocalDate date \u003d LocalDate.from(temporal);\n            LocalTime time \u003d LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain LocalDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30\", not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param date  the date part of the date-time, validated not null\n     * @param time  the time part of the date-time, validated not null\n     */\n    private LocalDateTime(LocalDate date, LocalTime time) {\n        this.date \u003d date;\n        this.time \u003d time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param newDate  the date of the new date-time, not null\n     * @param newTime  the time of the new date-time, not null\n     * @return the date-time, not null\n     */\n    private LocalDateTime with(LocalDate newDate, LocalTime newTime) {\n        if (date \u003d\u003d newDate \u0026\u0026 time \u003d\u003d newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return f.isDateBased() || f.isTimeBased();\n        }\n        return field !\u003d null \u0026\u0026 field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDateTime.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.range(field) : date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH} which are too large to fit in\n     * an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.get(field) : date.get(field));\n        }\n        return ChronoLocalDateTime.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.getLong(field) : date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    @Override\n    public LocalDate toLocalDate() {\n        return date;\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return date.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return date.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return date.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return date.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return date.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return date.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    @Override\n    public LocalTime toLocalTime() {\n        return time;\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return time.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return time.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return time.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return time.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@code TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d localDateTime.with(date);\n     *  result \u003d localDateTime.with(time);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return with((LocalDate) adjuster, time);\n        } else if (adjuster instanceof LocalTime) {\n            return with(date, (LocalTime) adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return (LocalDateTime) adjuster;\n        }\n        return (LocalDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}\n     * or {@link LocalTime#with(TemporalField, long) LocalTime}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isTimeBased()) {\n                return with(date, time.with(field, newValue));\n            } else {\n                return with(date.with(field, newValue), time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return with(date.withYear(year), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDateTime withMonth(int month) {\n        return with(date.withMonth(month), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return with(date.withDayOfMonth(dayOfMonth), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return with(date.withDayOfYear(dayOfYear), time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return a {@code LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public LocalDateTime withHour(int hour) {\n        LocalTime newTime \u003d time.withHour(hour);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public LocalDateTime withMinute(int minute) {\n        LocalTime newTime \u003d time.withMinute(minute);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public LocalDateTime withSecond(int second) {\n        LocalTime newTime \u003d time.withSecond(second);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return a {@code LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public LocalDateTime withNano(int nanoOfSecond) {\n        LocalTime newTime \u003d time.withNano(nanoOfSecond);\n        return with(date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return a {@code LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public LocalDateTime truncatedTo(TemporalUnit unit) {\n        return with(date, time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return with(date.plus(periodToAdd), time);\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * Date units are added as per {@link LocalDate#plus(long, TemporalUnit)}.\n     * Time units are added as per {@link LocalTime#plus(long, TemporalUnit)} with\n     * any overflow in days added equivalent to using {@link #plusDays(long)}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case NANOS: return plusNanos(amountToAdd);\n                case MICROS: return plusDays(amountToAdd / MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n                case MILLIS: return plusDays(amountToAdd / MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n                case SECONDS: return plusSeconds(amountToAdd);\n                case MINUTES: return plusMinutes(amountToAdd);\n                case HOURS: return plusHours(amountToAdd);\n                case HALF_DAYS: return plusDays(amountToAdd / 256).plusHours((amountToAdd % 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return with(date.plus(amountToAdd, unit), time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusYears(long years) {\n        LocalDate newDate \u003d date.plusYears(years);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMonths(long months) {\n        LocalDate newDate \u003d date.plusMonths(months);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusWeeks(long weeks) {\n        LocalDate newDate \u003d date.plusWeeks(weeks);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusDays(long days) {\n        LocalDate newDate \u003d date.plusDays(days);\n        return with(newDate, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return with(date.minus(periodToSubtract), time);\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, -1);\n   }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified period added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param newDate  the new date to base the calculation on, not null\n     * @param hours  the hours to add, may be negative\n     * @param minutes the minutes to add, may be negative\n     * @param seconds the seconds to add, may be negative\n     * @param nanos the nanos to add, may be negative\n     * @param sign  the sign to determine add or subtract\n     * @return the combined result, not null\n     */\n    private LocalDateTime plusWithOverflow(LocalDate newDate, long hours, long minutes, long seconds, long nanos, int sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) \u003d\u003d 0) {\n            return with(newDate, time);\n        }\n        long totDays \u003d nanos / NANOS_PER_DAY +             //   max/24*60*60*1B\n                seconds / SECONDS_PER_DAY +                //   max/24*60*60\n                minutes / MINUTES_PER_DAY +                //   max/24*60\n                hours / HOURS_PER_DAY;                     //   max/24\n        totDays *\u003d sign;                                   // total max*0.4237...\n        long totNanos \u003d nanos % NANOS_PER_DAY +                    //   max  86400000000000\n                (seconds % SECONDS_PER_DAY) * NANOS_PER_SECOND +   //   max  86400000000000\n                (minutes % MINUTES_PER_DAY) * NANOS_PER_MINUTE +   //   max  86400000000000\n                (hours % HOURS_PER_DAY) * NANOS_PER_HOUR;          //   max  86400000000000\n        long curNoD \u003d time.toNanoOfDay();                       //   max  86400000000000\n        totNanos \u003d totNanos * sign + curNoD;                    // total 432000000000000\n        totDays +\u003d Math.floorDiv(totNanos, NANOS_PER_DAY);\n        long newNoD \u003d Math.floorMod(totNanos, NANOS_PER_DAY);\n        LocalTime newTime \u003d (newNoD \u003d\u003d curNoD ? time : LocalTime.ofNanoOfDay(newNoD));\n        return with(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override  // override for Javadoc\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) date;\n        }\n        return ChronoLocalDateTime.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDateTime.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDateTime} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDateTime end \u003d LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                long amount \u003d date.daysUntil(end.date);\n                if (amount \u003d\u003d 0) {\n                    return time.until(end.time, unit);\n                }\n                long timePart \u003d end.time.toNanoOfDay() - time.toNanoOfDay();\n                if (amount \u003e 0) {\n                    amount--;  // safe\n                    timePart +\u003d NANOS_PER_DAY;  // safe\n                } else {\n                    amount++;  // safe\n                    timePart -\u003d NANOS_PER_DAY;  // safe\n                }\n                switch ((ChronoUnit) unit) {\n                    case NANOS:\n                        amount \u003d Math.multiplyExact(amount, NANOS_PER_DAY);\n                        break;\n                    case MICROS:\n                        amount \u003d Math.multiplyExact(amount, MICROS_PER_DAY);\n                        timePart \u003d timePart / 1000;\n                        break;\n                    case MILLIS:\n                        amount \u003d Math.multiplyExact(amount, MILLIS_PER_DAY);\n                        timePart \u003d timePart / 1_000_000;\n                        break;\n                    case SECONDS:\n                        amount \u003d Math.multiplyExact(amount, SECONDS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_SECOND;\n                        break;\n                    case MINUTES:\n                        amount \u003d Math.multiplyExact(amount, MINUTES_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_MINUTE;\n                        break;\n                    case HOURS:\n                        amount \u003d Math.multiplyExact(amount, HOURS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_HOUR;\n                        break;\n                    case HALF_DAYS:\n                        amount \u003d Math.multiplyExact(amount, 2);\n                        timePart \u003d timePart / (NANOS_PER_HOUR * 12);\n                        break;\n                }\n                return Math.addExact(amount, timePart);\n            }\n            LocalDate endDate \u003d end.date;\n            if (endDate.isAfter(date) \u0026\u0026 end.time.isBefore(time)) {\n                endDate \u003d endDate.minusDays(1);\n            } else if (endDate.isBefore(date) \u0026\u0026 end.time.isAfter(time)) {\n                endDate \u003d endDate.plusDays(1);\n            }\n            return date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param offset  the offset to combine with, not null\n     * @return the offset date-time formed from this date-time and the specified offset, not null\n     */\n    public OffsetDateTime atOffset(ZoneOffset offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * \u003cp\u003e\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *\u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    @Override\n    public ZonedDateTime atZone(ZoneId zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the date-times being compared are instances of {@code LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other);\n        }\n        return ChronoLocalDateTime.super.compareTo(other);\n    }\n\n    private int compareTo0(LocalDateTime other) {\n        int cmp \u003d date.compareTo0(other.toLocalDate());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is after the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003e 0;\n        }\n        return ChronoLocalDateTime.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is before the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003c 0;\n        }\n        return ChronoLocalDateTime.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is equal to the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDateTime.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * Compares this {@code LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@code LocalDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDateTime) {\n            LocalDateTime other \u003d (LocalDateTime) obj;\n            return date.equals(other.date) \u0026\u0026 time.equals(other.time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return date.hashCode() ^ time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSS}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return date.toString() + \u0027T\u0027 + time.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(5);  // identifies a LocalDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDate\"\u003edate\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalTime\"\u003etime\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        date.writeExternal(out);\n        time.writeExternal(out);\n    }\n\n    static LocalDateTime readExternal(DataInput in) throws IOException {\n        LocalDate date \u003d LocalDate.readExternal(in);\n        LocalTime time \u003d LocalTime.readExternal(in);\n        return LocalDateTime.of(date, time);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor25.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

nov. 07, 2024 8:51:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

nov. 07, 2024 8:51:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.HOURS_PER_DAY;\nimport static java.time.LocalTime.MICROS_PER_DAY;\nimport static java.time.LocalTime.MILLIS_PER_DAY;\nimport static java.time.LocalTime.MINUTES_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_HOUR;\nimport static java.time.LocalTime.NANOS_PER_MINUTE;\nimport static java.time.LocalTime.NANOS_PER_SECOND;\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n * \u003cp\u003e\n * {@code LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be\n * stored in a {@code LocalDateTime}.\n * \u003cp\u003e\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDateTime\n        implements Temporal, TemporalAdjuster, ChronoLocalDateTime\u003cLocalDate\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDateTime}, \u0027-999999999-01-01T00:00:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final LocalDateTime MIN \u003d LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n    /**\n     * The maximum supported {@code LocalDateTime}, \u0027+999999999-12-31T23:59:59.999999999\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final LocalDateTime MAX \u003d LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 6207766400415563566L;\n\n    /**\n     * The date part.\n     */\n    private final LocalDate date;\n    /**\n     * The time part.\n     */\n    private final LocalTime time;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock and default time-zone, not null\n     */\n    public static LocalDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static LocalDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static LocalDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        ZoneOffset offset \u003d clock.getZone().getRules().getOffset(now);\n        return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a date and time.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @return the local date-time, not null\n     */\n    public static LocalDateTime of(LocalDate date, LocalTime time) {\n        Objects.requireNonNull(date, \"date\");\n        Objects.requireNonNull(time, \"time\");\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static LocalDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        return ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows the {@link ChronoField#INSTANT_SECONDS epoch-second} field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param epochSecond  the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param nanoOfSecond  the nanosecond within the second, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range,\n     *  or if the nano-of-second is invalid\n     */\n    public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) {\n        Objects.requireNonNull(offset, \"offset\");\n        NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        long localSecond \u003d epochSecond + offset.getTotalSeconds();  // overflow caught later\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        int secsOfDay \u003d Math.floorMod(localSecond, SECONDS_PER_DAY);\n        LocalDate date \u003d LocalDate.ofEpochDay(localEpochDay);\n        LocalTime time \u003d LocalTime.ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion extracts and combines the {@code LocalDate} and the\n     * {@code LocalTime} from the temporal object.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDateTime}\n     */\n    public static LocalDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof LocalDateTime) {\n            return (LocalDateTime) temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return ((ZonedDateTime) temporal).toLocalDateTime();\n        } else if (temporal instanceof OffsetDateTime) {\n            return ((OffsetDateTime) temporal).toLocalDateTime();\n        }\n        try {\n            LocalDate date \u003d LocalDate.from(temporal);\n            LocalTime time \u003d LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain LocalDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30\", not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param date  the date part of the date-time, validated not null\n     * @param time  the time part of the date-time, validated not null\n     */\n    private LocalDateTime(LocalDate date, LocalTime time) {\n        this.date \u003d date;\n        this.time \u003d time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param newDate  the date of the new date-time, not null\n     * @param newTime  the time of the new date-time, not null\n     * @return the date-time, not null\n     */\n    private LocalDateTime with(LocalDate newDate, LocalTime newTime) {\n        if (date \u003d\u003d newDate \u0026\u0026 time \u003d\u003d newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return f.isDateBased() || f.isTimeBased();\n        }\n        return field !\u003d null \u0026\u0026 field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDateTime.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.range(field) : date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH} which are too large to fit in\n     * an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.get(field) : date.get(field));\n        }\n        return ChronoLocalDateTime.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.getLong(field) : date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    @Override\n    public LocalDate toLocalDate() {\n        return date;\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return date.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return date.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return date.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return date.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return date.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return date.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    @Override\n    public LocalTime toLocalTime() {\n        return time;\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return time.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return time.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return time.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return time.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@code TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d localDateTime.with(date);\n     *  result \u003d localDateTime.with(time);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return with((LocalDate) adjuster, time);\n        } else if (adjuster instanceof LocalTime) {\n            return with(date, (LocalTime) adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return (LocalDateTime) adjuster;\n        }\n        return (LocalDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}\n     * or {@link LocalTime#with(TemporalField, long) LocalTime}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isTimeBased()) {\n                return with(date, time.with(field, newValue));\n            } else {\n                return with(date.with(field, newValue), time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return with(date.withYear(year), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDateTime withMonth(int month) {\n        return with(date.withMonth(month), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return with(date.withDayOfMonth(dayOfMonth), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return with(date.withDayOfYear(dayOfYear), time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return a {@code LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public LocalDateTime withHour(int hour) {\n        LocalTime newTime \u003d time.withHour(hour);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public LocalDateTime withMinute(int minute) {\n        LocalTime newTime \u003d time.withMinute(minute);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public LocalDateTime withSecond(int second) {\n        LocalTime newTime \u003d time.withSecond(second);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return a {@code LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public LocalDateTime withNano(int nanoOfSecond) {\n        LocalTime newTime \u003d time.withNano(nanoOfSecond);\n        return with(date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return a {@code LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public LocalDateTime truncatedTo(TemporalUnit unit) {\n        return with(date, time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return with(date.plus(periodToAdd), time);\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * Date units are added as per {@link LocalDate#plus(long, TemporalUnit)}.\n     * Time units are added as per {@link LocalTime#plus(long, TemporalUnit)} with\n     * any overflow in days added equivalent to using {@link #plusDays(long)}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case NANOS: return plusNanos(amountToAdd);\n                case MICROS: return plusDays(amountToAdd / MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n                case MILLIS: return plusDays(amountToAdd / MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n                case SECONDS: return plusSeconds(amountToAdd);\n                case MINUTES: return plusMinutes(amountToAdd);\n                case HOURS: return plusHours(amountToAdd);\n                case HALF_DAYS: return plusDays(amountToAdd / 256).plusHours((amountToAdd % 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return with(date.plus(amountToAdd, unit), time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusYears(long years) {\n        LocalDate newDate \u003d date.plusYears(years);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMonths(long months) {\n        LocalDate newDate \u003d date.plusMonths(months);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusWeeks(long weeks) {\n        LocalDate newDate \u003d date.plusWeeks(weeks);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusDays(long days) {\n        LocalDate newDate \u003d date.plusDays(days);\n        return with(newDate, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return with(date.minus(periodToSubtract), time);\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, -1);\n   }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified period added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param newDate  the new date to base the calculation on, not null\n     * @param hours  the hours to add, may be negative\n     * @param minutes the minutes to add, may be negative\n     * @param seconds the seconds to add, may be negative\n     * @param nanos the nanos to add, may be negative\n     * @param sign  the sign to determine add or subtract\n     * @return the combined result, not null\n     */\n    private LocalDateTime plusWithOverflow(LocalDate newDate, long hours, long minutes, long seconds, long nanos, int sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) \u003d\u003d 0) {\n            return with(newDate, time);\n        }\n        long totDays \u003d nanos / NANOS_PER_DAY +             //   max/24*60*60*1B\n                seconds / SECONDS_PER_DAY +                //   max/24*60*60\n                minutes / MINUTES_PER_DAY +                //   max/24*60\n                hours / HOURS_PER_DAY;                     //   max/24\n        totDays *\u003d sign;                                   // total max*0.4237...\n        long totNanos \u003d nanos % NANOS_PER_DAY +                    //   max  86400000000000\n                (seconds % SECONDS_PER_DAY) * NANOS_PER_SECOND +   //   max  86400000000000\n                (minutes % MINUTES_PER_DAY) * NANOS_PER_MINUTE +   //   max  86400000000000\n                (hours % HOURS_PER_DAY) * NANOS_PER_HOUR;          //   max  86400000000000\n        long curNoD \u003d time.toNanoOfDay();                       //   max  86400000000000\n        totNanos \u003d totNanos * sign + curNoD;                    // total 432000000000000\n        totDays +\u003d Math.floorDiv(totNanos, NANOS_PER_DAY);\n        long newNoD \u003d Math.floorMod(totNanos, NANOS_PER_DAY);\n        LocalTime newTime \u003d (newNoD \u003d\u003d curNoD ? time : LocalTime.ofNanoOfDay(newNoD));\n        return with(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override  // override for Javadoc\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) date;\n        }\n        return ChronoLocalDateTime.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDateTime.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDateTime} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDateTime end \u003d LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                long amount \u003d date.daysUntil(end.date);\n                if (amount \u003d\u003d 0) {\n                    return time.until(end.time, unit);\n                }\n                long timePart \u003d end.time.toNanoOfDay() - time.toNanoOfDay();\n                if (amount \u003e 0) {\n                    amount--;  // safe\n                    timePart +\u003d NANOS_PER_DAY;  // safe\n                } else {\n                    amount++;  // safe\n                    timePart -\u003d NANOS_PER_DAY;  // safe\n                }\n                switch ((ChronoUnit) unit) {\n                    case NANOS:\n                        amount \u003d Math.multiplyExact(amount, NANOS_PER_DAY);\n                        break;\n                    case MICROS:\n                        amount \u003d Math.multiplyExact(amount, MICROS_PER_DAY);\n                        timePart \u003d timePart / 1000;\n                        break;\n                    case MILLIS:\n                        amount \u003d Math.multiplyExact(amount, MILLIS_PER_DAY);\n                        timePart \u003d timePart / 1_000_000;\n                        break;\n                    case SECONDS:\n                        amount \u003d Math.multiplyExact(amount, SECONDS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_SECOND;\n                        break;\n                    case MINUTES:\n                        amount \u003d Math.multiplyExact(amount, MINUTES_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_MINUTE;\n                        break;\n                    case HOURS:\n                        amount \u003d Math.multiplyExact(amount, HOURS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_HOUR;\n                        break;\n                    case HALF_DAYS:\n                        amount \u003d Math.multiplyExact(amount, 2);\n                        timePart \u003d timePart / (NANOS_PER_HOUR * 12);\n                        break;\n                }\n                return Math.addExact(amount, timePart);\n            }\n            LocalDate endDate \u003d end.date;\n            if (endDate.isAfter(date) \u0026\u0026 end.time.isBefore(time)) {\n                endDate \u003d endDate.minusDays(1);\n            } else if (endDate.isBefore(date) \u0026\u0026 end.time.isAfter(time)) {\n                endDate \u003d endDate.plusDays(1);\n            }\n            return date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param offset  the offset to combine with, not null\n     * @return the offset date-time formed from this date-time and the specified offset, not null\n     */\n    public OffsetDateTime atOffset(ZoneOffset offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * \u003cp\u003e\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *\u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    @Override\n    public ZonedDateTime atZone(ZoneId zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the date-times being compared are instances of {@code LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other);\n        }\n        return ChronoLocalDateTime.super.compareTo(other);\n    }\n\n    private int compareTo0(LocalDateTime other) {\n        int cmp \u003d date.compareTo0(other.toLocalDate());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is after the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003e 0;\n        }\n        return ChronoLocalDateTime.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is before the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003c 0;\n        }\n        return ChronoLocalDateTime.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is equal to the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDateTime.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * Compares this {@code LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@code LocalDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDateTime) {\n            LocalDateTime other \u003d (LocalDateTime) obj;\n            return date.equals(other.date) \u0026\u0026 time.equals(other.time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return date.hashCode() ^ time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSS}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return date.toString() + \u0027T\u0027 + time.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(5);  // identifies a LocalDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDate\"\u003edate\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalTime\"\u003etime\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        date.writeExternal(out);\n        time.writeExternal(out);\n    }\n\n    static LocalDateTime readExternal(DataInput in) throws IOException {\n        LocalDate date \u003d LocalDate.readExternal(in);\n        LocalTime time \u003d LocalTime.readExternal(in);\n        return LocalDateTime.of(date, time);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor25.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

nov. 07, 2024 8:51:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/LocalDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.11.07 20:51:26 INFO  compiling root (3 scala sources)
2024.11.07 20:51:26 INFO  time: compiled root in 0.33s
2024.11.07 20:51:37 INFO  compiling root (3 scala sources)
2024.11.07 20:51:37 INFO  time: compiled root in 0.3s
2024.11.07 20:52:00 WARN  Could not find 'Room' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.07 20:52:01 WARN  Could not find 'Room' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.07 20:52:02 WARN  Could not find 'Room' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.07 20:52:08 INFO  compiling root (3 scala sources)
2024.11.07 20:52:08 INFO  time: compiled root in 0.29s
2024.11.07 20:52:51 INFO  compiling root (3 scala sources)
2024.11.07 20:52:51 INFO  time: compiled root in 0.39s
2024.11.07 20:55:30 INFO  compiling root (4 scala sources)
2024.11.07 20:55:30 INFO  time: compiled root in 0.4s
2024.11.07 20:55:37 INFO  compiling root (4 scala sources)
2024.11.07 20:55:37 INFO  time: compiled root in 0.32s
2024.11.07 20:56:32 INFO  compiling root (5 scala sources)
2024.11.07 20:56:33 INFO  time: compiled root in 1.18s
2024.11.07 20:56:33 INFO  compiling root (1 scala source)
2024.11.07 20:56:33 INFO  time: compiled root in 0.26s
2024.11.07 20:58:47 INFO  compiling root (1 scala source)
2024.11.07 20:58:47 INFO  time: compiled root in 0.27s
2024.11.07 20:58:47 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:54 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:55 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:57 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:58:59 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala
2024.11.07 20:59:00 INFO  time: compiled root in 11ms
nov. 07, 2024 8:59:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4169
nov. 07, 2024 9:00:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4205
2024.11.07 21:00:27 INFO  compiling root (1 scala source)
2024.11.07 21:00:27 INFO  time: compiled root in 0.69s
2024.11.07 21:01:21 INFO  compiling root (1 scala source)
2024.11.07 21:01:21 INFO  time: compiled root in 0.68s
2024.11.07 21:02:14 INFO  compiling root (1 scala source)
2024.11.07 21:02:14 INFO  time: compiled root in 0.73s
2024.11.07 21:03:03 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\ReservationController.scala
2024.11.07 21:03:03 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\ReservationController.scala
2024.11.07 21:03:03 INFO  compiling root (1 scala source)
2024.11.07 21:03:03 INFO  time: compiled root in 0.83s
2024.11.07 21:07:44 INFO  compiling root (1 scala source)
2024.11.07 21:07:44 INFO  time: compiled root in 0.71s
2024.11.07 21:08:03 INFO  compiling root (1 scala source)
2024.11.07 21:08:03 INFO  time: compiled root in 0.7s
2024.11.07 21:08:08 INFO  compiling root (1 scala source)
2024.11.07 21:08:08 INFO  time: compiled root in 0.71s
2024.11.07 22:47:15 INFO  compiling root (1 scala source)
2024.11.07 22:47:16 INFO  time: compiled root in 1.07s
2024.11.07 22:47:35 INFO  compiling root (1 scala source)
2024.11.07 22:47:35 INFO  time: compiled root in 0.6s
2024.11.07 22:54:54 INFO  compiling root (1 scala source)
2024.11.07 22:54:54 INFO  time: compiled root in 0.88s
2024.11.07 22:54:54 INFO  compiling root (4 scala sources)
2024.11.07 22:54:55 INFO  time: compiled root in 0.44s
2024.11.07 22:54:55 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Reservation.scala
2024.11.07 22:54:59 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Reservation.scala
2024.11.07 22:55:04 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Reservation.scala
2024.11.07 22:55:08 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Reservation.scala
2024.11.07 22:55:14 INFO  time: compiled root in 24ms
2024.11.07 22:57:19 INFO  compiling root (1 scala source)
2024.11.07 22:57:19 INFO  time: compiled root in 0.84s
2024.11.07 22:57:35 INFO  compiling root (1 scala source)
2024.11.07 22:57:35 INFO  time: compiled root in 0.84s
2024.11.07 23:01:59 INFO  compiling root (1 scala source)
2024.11.07 23:02:00 INFO  time: compiled root in 1.25s
2024.11.07 23:02:16 INFO  compiling root (1 scala source)
2024.11.07 23:02:16 INFO  time: compiled root in 0.25s
2024.11.07 23:02:23 INFO  time: compiled root in 24ms
2024.11.07 23:02:31 INFO  compiling root (1 scala source)
2024.11.07 23:02:31 INFO  time: compiled root in 0.26s
2024.11.07 23:02:37 INFO  compiling root (1 scala source)
2024.11.07 23:02:37 INFO  time: compiled root in 0.13s
2024.11.07 23:02:37 INFO  compiling root (1 scala source)
2024.11.07 23:02:37 INFO  time: compiled root in 0.14s
2024.11.07 23:03:10 WARN  Could not find 'routes' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
nov. 07, 2024 11:03:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5013
nov. 07, 2024 11:03:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5025
2024.11.07 23:03:50 INFO  compiling root (1 scala source)
2024.11.07 23:03:50 INFO  time: compiled root in 0.2s
2024.11.07 23:04:13 INFO  compiling root (1 scala source)
2024.11.07 23:04:13 INFO  time: compiled root in 0.14s
2024.11.07 23:04:16 INFO  compiling root (1 scala source)
2024.11.07 23:04:16 INFO  time: compiled root in 0.83s
2024.11.07 23:10:43 INFO  compiling root (1 scala source)
2024.11.07 23:10:44 INFO  time: compiled root in 1.44s
nov. 07, 2024 11:11:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5148
2024.11.07 23:11:11 INFO  compiling root (1 scala source)
2024.11.07 23:11:11 INFO  time: compiled root in 0.17s
nov. 07, 2024 11:11:13 PM scala.meta.internal.pc.CompletionProvider expected$1
ADVERTÊNCIA: offset 2736, count -1, length 2762
2024.11.07 23:11:20 INFO  compiling root (1 scala source)
2024.11.07 23:11:21 INFO  time: compiled root in 1.44s
2024.11.07 23:11:30 INFO  compiling root (1 scala source)
2024.11.07 23:11:30 INFO  time: compiled root in 0.36s
nov. 07, 2024 11:11:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2008-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time.format;\n\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_WEEK;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.IOException;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.time.DateTimeException;\nimport java.time.Period;\nimport java.time.ZoneId;\nimport java.time.ZoneOffset;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.chrono.Chronology;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatterBuilder.CompositePrinterParser;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.IsoFields;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQuery;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport sun.util.locale.provider.TimeZoneNameUtility;\n\n/**\n * Formatter for printing and parsing date-time objects.\n * \u003cp\u003e\n * This class provides the main application entry point for printing and parsing\n * and provides common implementations of {@code DateTimeFormatter}:\n * \u003cul\u003e\n * \u003cli\u003eUsing predefined constants, such as {@link #ISO_LOCAL_DATE}\u003c/li\u003e\n * \u003cli\u003eUsing pattern letters, such as {@code uuuu-MMM-dd}\u003c/li\u003e\n * \u003cli\u003eUsing localized styles, such as {@code long} or {@code medium}\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * More complex formatters are provided by\n * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.\n *\n * \u003cp\u003e\n * The main date-time classes provide two methods - one for formatting,\n * {@code format(DateTimeFormatter formatter)}, and one for parsing,\n * {@code parse(CharSequence text, DateTimeFormatter formatter)}.\n * \u003cp\u003eFor example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * In addition to the format, formatters can be created with desired Locale,\n * Chronology, ZoneId, and DecimalStyle.\n * \u003cp\u003e\n * The {@link #withLocale withLocale} method returns a new formatter that\n * overrides the locale. The locale affects some aspects of formatting and\n * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a\n * formatter that uses the locale specific date format.\n * \u003cp\u003e\n * The {@link #withChronology withChronology} method returns a new formatter\n * that overrides the chronology. If overridden, the date-time value is\n * converted to the chronology before formatting. During parsing the date-time\n * value is converted to the chronology before it is returned.\n * \u003cp\u003e\n * The {@link #withZone withZone} method returns a new formatter that overrides\n * the zone. If overridden, the date-time value is converted to a ZonedDateTime\n * with the requested ZoneId before formatting. During parsing the ZoneId is\n * applied before the value is returned.\n * \u003cp\u003e\n * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that\n * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for\n * formatting and parsing.\n * \u003cp\u003e\n * Some applications may need to use the older {@link Format java.text.Format}\n * class for formatting. The {@link #toFormat()} method returns an\n * implementation of {@code java.text.Format}.\n *\n * \u003ch3 id\u003d\"predefined\"\u003ePredefined Formatters\u003c/h3\u003e\n * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n * \u003ccaption\u003ePredefined Formatters\u003c/caption\u003e\n * \u003cthead\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"col\"\u003eFormatter\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eExample\u003c/th\u003e\n * \u003c/tr\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with date style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with time style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with a style for date and time from the locale\u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}\n * \u003c/th\u003e\n * \u003ctd\u003e Formatter with date and time styles from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #BASIC_ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003eBasic ISO date \u003c/td\u003e \u003ctd\u003e\u002720111203\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with offset \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with or without offset \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03+01:00\u0027; \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with or without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027; \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date and Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date Time with Offset\n * \u003c/td\u003e\u003ctd\u003e\u00272011-12-03T10:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ZONED_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Zoned Date Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date and time with ZoneId \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ORDINAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and day of year \u003c/td\u003e\n * \u003ctd\u003e\u00272012-337\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_WEEK_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and Week \u003c/td\u003e\n * \u003ctd\u003e\u00272012-W48-6\u0027\u003c/td\u003e\u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_INSTANT}\u003c/th\u003e\n * \u003ctd\u003e Date and Time of an Instant \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30Z\u0027 \u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #RFC_1123_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e RFC 1123 / RFC 822 \u003c/td\u003e\n * \u003ctd\u003e\u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n *\n * \u003ch3 id\u003d\"patterns\"\u003ePatterns for Formatting and Parsing\u003c/h3\u003e\n * Patterns are based on a simple sequence of letters and symbols.\n * A pattern is used to create a Formatter using the\n * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.\n * For example,\n * {@code \"d MMM uuuu\"} will format 2011-12-03 as \u00273\u0026nbsp;Dec\u0026nbsp;2011\u0027.\n * A formatter created from a pattern can be used as many times as necessary,\n * it is immutable and is thread-safe.\n * \u003cp\u003e\n * For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  DateTimeFormatter formatter \u003d DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * All letters \u0027A\u0027 to \u0027Z\u0027 and \u0027a\u0027 to \u0027z\u0027 are reserved as pattern letters. The\n * following pattern letters are defined:\n * \u003ctable class\u003d\"striped\"\u003e\n * \u003ccaption\u003ePattern Letters and Symbols\u003c/caption\u003e\n * \u003cthead\u003e\n *  \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSymbol\u003c/th\u003e   \u003cth scope\u003d\"col\"\u003eMeaning\u003c/th\u003e         \u003cth scope\u003d\"col\"\u003ePresentation\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eExamples\u003c/th\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eG\u003c/th\u003e       \u003ctd\u003eera\u003c/td\u003e                         \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eAD; Anno Domini; A\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eu\u003c/th\u003e       \u003ctd\u003eyear\u003c/td\u003e                        \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ey\u003c/th\u003e       \u003ctd\u003eyear-of-era\u003c/td\u003e                 \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eD\u003c/th\u003e       \u003ctd\u003eday-of-year\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e189\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eM/L\u003c/th\u003e     \u003ctd\u003emonth-of-year\u003c/td\u003e               \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e7; 07; Jul; July; J\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ed\u003c/th\u003e       \u003ctd\u003eday-of-month\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e10\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eg\u003c/th\u003e       \u003ctd\u003emodified-julian-day\u003c/td\u003e         \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e2451334\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eQ/q\u003c/th\u003e     \u003ctd\u003equarter-of-year\u003c/td\u003e             \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e3; 03; Q3; 3rd quarter\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eY\u003c/th\u003e       \u003ctd\u003eweek-based-year\u003c/td\u003e             \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e1996; 96\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ew\u003c/th\u003e       \u003ctd\u003eweek-of-week-based-year\u003c/td\u003e     \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e27\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eW\u003c/th\u003e       \u003ctd\u003eweek-of-month\u003c/td\u003e               \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e4\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eE\u003c/th\u003e       \u003ctd\u003eday-of-week\u003c/td\u003e                 \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eTue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ee/c\u003c/th\u003e     \u003ctd\u003elocalized day-of-week\u003c/td\u003e       \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e2; 02; Tue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eF\u003c/th\u003e       \u003ctd\u003eday-of-week-in-month\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e3\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ea\u003c/th\u003e       \u003ctd\u003eam-pm-of-day\u003c/td\u003e                \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003ePM\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eh\u003c/th\u003e       \u003ctd\u003eclock-hour-of-am-pm (1-12)\u003c/td\u003e  \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e12\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eK\u003c/th\u003e       \u003ctd\u003ehour-of-am-pm (0-11)\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ek\u003c/th\u003e       \u003ctd\u003eclock-hour-of-day (1-24)\u003c/td\u003e    \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e24\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eH\u003c/th\u003e       \u003ctd\u003ehour-of-day (0-23)\u003c/td\u003e          \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003em\u003c/th\u003e       \u003ctd\u003eminute-of-hour\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003es\u003c/th\u003e       \u003ctd\u003esecond-of-minute\u003c/td\u003e            \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e55\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eS\u003c/th\u003e       \u003ctd\u003efraction-of-second\u003c/td\u003e          \u003ctd\u003efraction\u003c/td\u003e          \u003ctd\u003e978\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eA\u003c/th\u003e       \u003ctd\u003emilli-of-day\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003en\u003c/th\u003e       \u003ctd\u003enano-of-second\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e987654321\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eN\u003c/th\u003e       \u003ctd\u003enano-of-day\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234000000\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eV\u003c/th\u003e       \u003ctd\u003etime-zone ID\u003c/td\u003e                \u003ctd\u003ezone-id\u003c/td\u003e           \u003ctd\u003eAmerica/Los_Angeles; Z; -08:30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ev\u003c/th\u003e       \u003ctd\u003egeneric time-zone name\u003c/td\u003e      \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Time; PT\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ez\u003c/th\u003e       \u003ctd\u003etime-zone name\u003c/td\u003e              \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Standard Time; PST\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eO\u003c/th\u003e       \u003ctd\u003elocalized zone-offset\u003c/td\u003e       \u003ctd\u003eoffset-O\u003c/td\u003e          \u003ctd\u003eGMT+8; GMT+08:00; UTC-08:00\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eX\u003c/th\u003e       \u003ctd\u003ezone-offset \u0027Z\u0027 for zero\u003c/td\u003e    \u003ctd\u003eoffset-X\u003c/td\u003e          \u003ctd\u003eZ; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ex\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-x\u003c/td\u003e          \u003ctd\u003e+0000; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eZ\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-Z\u003c/td\u003e          \u003ctd\u003e+0000; -0800; -08:00\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ep\u003c/th\u003e       \u003ctd\u003epad next\u003c/td\u003e                    \u003ctd\u003epad modifier\u003c/td\u003e      \u003ctd\u003e1\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u003c/th\u003e       \u003ctd\u003eescape for text\u003c/td\u003e             \u003ctd\u003edelimiter\u003c/td\u003e         \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u0027\u003c/th\u003e      \u003ctd\u003esingle quote\u003c/td\u003e                \u003ctd\u003eliteral\u003c/td\u003e           \u003ctd\u003e\u0027\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e[\u003c/th\u003e       \u003ctd\u003eoptional section start\u003c/td\u003e      \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e]\u003c/th\u003e       \u003ctd\u003eoptional section end\u003c/td\u003e        \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e#\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e}\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n * \u003cp\u003e\n * The count of pattern letters determines the format.\n * \u003cp\u003e\n * \u003cb\u003eText\u003c/b\u003e: The text style is determined based on the number of pattern\n * letters used. Less than 4 pattern letters will use the\n * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the\n * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the\n * {@link TextStyle#NARROW narrow form}.\n * Pattern letters \u0027L\u0027, \u0027c\u0027, and \u0027q\u0027 specify the stand-alone form of the text styles.\n * \u003cp\u003e\n * \u003cb\u003eNumber\u003c/b\u003e: If the count of letters is one, then the value is output using\n * the minimum number of digits and without padding. Otherwise, the count of digits\n * is used as the width of the output field, with the value zero-padded as necessary.\n * The following pattern letters have constraints on the count of letters.\n * Only one letter of \u0027c\u0027 and \u0027F\u0027 can be specified.\n * Up to two letters of \u0027d\u0027, \u0027H\u0027, \u0027h\u0027, \u0027K\u0027, \u0027k\u0027, \u0027m\u0027, and \u0027s\u0027 can be specified.\n * Up to three letters of \u0027D\u0027 can be specified.\n * \u003cp\u003e\n * \u003cb\u003eNumber/Text\u003c/b\u003e: If the count of pattern letters is 3 or greater, use the\n * Text rules above. Otherwise use the Number rules above.\n * \u003cp\u003e\n * \u003cb\u003eFraction\u003c/b\u003e: Outputs the nano-of-second field as a fraction-of-second.\n * The nano-of-second value has nine digits, thus the count of pattern letters\n * is from 1 to 9. If it is less than 9, then the nano-of-second value is\n * truncated, with only the most significant digits being output.\n * \u003cp\u003e\n * \u003cb\u003eYear\u003c/b\u003e: The count of letters determines the minimum field width below\n * which padding is used. If the count of letters is two, then a\n * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is\n * used. For printing, this outputs the rightmost two digits. For parsing, this\n * will parse using the base value of 2000, resulting in a year within the range\n * 2000 to 2099 inclusive. If the count of letters is less than four (but not\n * two), then the sign is only output for negative years as per\n * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is\n * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.\n * \u003cp\u003e\n * \u003cb\u003eZoneId\u003c/b\u003e: This outputs the time-zone ID, such as \u0027Europe/Paris\u0027. If the\n * count of letters is two, then the time-zone ID is output. Any other count of\n * letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eZone names\u003c/b\u003e: This outputs the display name of the time-zone ID. If the\n * pattern letter is \u0027z\u0027 the output is the daylight savings aware zone name.\n * If there is insufficient information to determine whether DST applies,\n * the name ignoring daylight savings time will be used.\n * If the count of letters is one, two or three, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Five or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * If the pattern letter is \u0027v\u0027 the output provides the zone name ignoring\n * daylight savings time. If the count of letters is one, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Two, three and five or more letters throw {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset X and x\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One letter outputs just the hour, such as \u0027+01\u0027, unless the minute\n * is non-zero in which case the minute is also output, such as \u0027+0130\u0027. Two\n * letters outputs the hour and minute, without a colon, such as \u0027+0130\u0027. Three\n * letters outputs the hour and minute, with a colon, such as \u0027+01:30\u0027. Four\n * letters outputs the hour and minute and optional second, without a colon,\n * such as \u0027+013015\u0027. Five letters outputs the hour and minute and optional\n * second, with a colon, such as \u0027+01:30:15\u0027. Six or more letters throws\n * {@code IllegalArgumentException}. Pattern letter \u0027X\u0027 (upper case) will output\n * \u0027Z\u0027 when the offset to be output would be zero, whereas pattern letter \u0027x\u0027\n * (lower case) will output \u0027+00\u0027, \u0027+0000\u0027, or \u0027+00:00\u0027.\n * \u003cp\u003e\n * \u003cb\u003eOffset O\u003c/b\u003e: This formats the localized offset based on the number of\n * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}\n * form of the localized offset, which is localized offset text, such as \u0027GMT\u0027,\n * with hour without leading zero, optional 2-digit minute and second if\n * non-zero, and colon, for example \u0027GMT+8\u0027. Four letters outputs the\n * {@linkplain TextStyle#FULL full} form, which is localized offset text,\n * such as \u0027GMT, with 2-digit hour and minute field, optional second field\n * if non-zero, and colon, for example \u0027GMT+08:00\u0027. Any other count of letters\n * throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset Z\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One, two or three letters outputs the hour and minute, without a\n * colon, such as \u0027+0130\u0027. The output will be \u0027+0000\u0027 when the offset is zero.\n * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized\n * offset, equivalent to four letters of Offset-O. The output will be the\n * corresponding localized offset text if the offset is zero. Five\n * letters outputs the hour, minute, with optional second if non-zero, with\n * colon. It outputs \u0027Z\u0027 if the offset is zero.\n * Six or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOptional section\u003c/b\u003e: The optional section markers work exactly like\n * calling {@link DateTimeFormatterBuilder#optionalStart()} and\n * {@link DateTimeFormatterBuilder#optionalEnd()}.\n * \u003cp\u003e\n * \u003cb\u003ePad modifier\u003c/b\u003e: Modifies the pattern that immediately follows to be\n * padded with spaces. The pad width is determined by the number of pattern\n * letters. This is the same as calling\n * {@link DateTimeFormatterBuilder#padNext(int)}.\n * \u003cp\u003e\n * For example, \u0027ppH\u0027 outputs the hour-of-day padded on the left with spaces to\n * a width of 2.\n * \u003cp\u003e\n * Any unrecognized letter is an error. Any non-letter character, other than\n * \u0027[\u0027, \u0027]\u0027, \u0027{\u0027, \u0027}\u0027, \u0027#\u0027 and the single quote will be output directly.\n * Despite this, it is recommended to use single quotes around all characters\n * that you want to output directly to ensure that future changes do not break\n * your application.\n *\n * \u003ch3 id\u003d\"resolving\"\u003eResolving\u003c/h3\u003e\n * Parsing is implemented as a two-phase operation.\n * First, the text is parsed using the layout defined by the formatter, producing\n * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n * simplifying the various fields into more useful ones.\n * \u003cp\u003e\n * Five parsing methods are supplied by this class.\n * Four of these perform both the parse and resolve phases.\n * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},\n * only performs the first phase, leaving the result unresolved.\n * As such, it is essentially a low-level operation.\n * \u003cp\u003e\n * The resolve phase is controlled by two parameters, set on this class.\n * \u003cp\u003e\n * The {@link ResolverStyle} is an enum that offers three different approaches,\n * strict, smart and lenient. The smart option is the default.\n * It can be set using {@link #withResolverStyle(ResolverStyle)}.\n * \u003cp\u003e\n * The {@link #withResolverFields(TemporalField...)} parameter allows the\n * set of fields that will be resolved to be filtered before resolving starts.\n * For example, if the formatter has parsed a year, month, day-of-month\n * and day-of-year, then there are two approaches to resolve a date:\n * (year + month + day-of-month) and (year + day-of-year).\n * The resolver fields allows one of the two approaches to be selected.\n * If no resolver fields are set then both approaches must result in the same date.\n * \u003cp\u003e\n * Resolving separate fields to form a complete date and time is a complex\n * process with behaviour distributed across a number of classes.\n * It follows these steps:\n * \u003col\u003e\n * \u003cli\u003eThe chronology is determined.\n * The chronology of the result is either the chronology that was parsed,\n * or if no chronology was parsed, it is the chronology set on this class,\n * or if that is null, it is {@code IsoChronology}.\n * \u003cli\u003eThe {@code ChronoField} date fields are resolved.\n * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code Chronology}.\n * \u003cli\u003eThe {@code ChronoField} time fields are resolved.\n * This is documented on {@link ChronoField} and is the same for all chronologies.\n * \u003cli\u003eAny fields that are not {@code ChronoField} are processed.\n * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code TemporalField}.\n * \u003cli\u003eThe {@code ChronoField} date and time fields are re-resolved.\n * This allows fields in step four to produce {@code ChronoField} values\n * and have them be processed into dates and times.\n * \u003cli\u003eA {@code LocalTime} is formed if there is at least an hour-of-day available.\n * This involves providing default values for minute, second and fraction of second.\n * \u003cli\u003eAny remaining unresolved fields are cross-checked against any\n * date and/or time that was resolved. Thus, an earlier stage would resolve\n * (year + month + day-of-month) to a date, and this stage would check that\n * day-of-week was valid for the date.\n * \u003cli\u003eIf an {@linkplain #parsedExcessDays() excess number of days}\n * was parsed then it is added to the date if a date is available.\n * \u003cli\u003e If a second-based field is present, but {@code LocalTime} was not parsed,\n * then the resolver ensures that milli, micro and nano second values are\n * available to meet the contract of {@link ChronoField}.\n * These will be set to zero if missing.\n * \u003cli\u003eIf both date and time were parsed and either an offset or zone is present,\n * the field {@link ChronoField#INSTANT_SECONDS} is created.\n * If an offset was parsed then the offset will be combined with the\n * {@code LocalDateTime} to form the instant, with any zone ignored.\n * If a {@code ZoneId} was parsed without an offset then the zone will be\n * combined with the {@code LocalDateTime} to form the instant using the rules\n * of {@link ChronoLocalDateTime#atZone(ZoneId)}.\n * \u003c/ol\u003e\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class DateTimeFormatter {\n\n    /**\n     * The printer and/or parser to use, not null.\n     */\n    private final CompositePrinterParser printerParser;\n    /**\n     * The locale to use for formatting, not null.\n     */\n    private final Locale locale;\n    /**\n     * The symbols to use for formatting, not null.\n     */\n    private final DecimalStyle decimalStyle;\n    /**\n     * The resolver style to use, not null.\n     */\n    private final ResolverStyle resolverStyle;\n    /**\n     * The fields to use in resolving, null for all fields.\n     */\n    private final Set\u003cTemporalField\u003e resolverFields;\n    /**\n     * The chronology to use for formatting, null for no override.\n     */\n    private final Chronology chrono;\n    /**\n     * The zone to use for formatting, null for no override.\n     */\n    private final ZoneId zone;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a formatter using the specified pattern.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n    /**\n     * Creates a formatter using the specified pattern and locale.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the specified locale.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern, Locale locale) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a locale specific date format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param dateStyle  the formatter style to obtain, not null\n     * @return the date formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param timeStyle  the formatter style to obtain, not null\n     * @return the time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle) {\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(null, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date-time formatter for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateTimeStyle  the formatter style to obtain, not null\n     * @return the date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle) {\n        Objects.requireNonNull(dateTimeStyle, \"dateTimeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateTimeStyle, dateTimeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date and time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault() default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateStyle  the date formatter style to obtain, not null\n     * @param timeStyle  the time formatter style to obtain, not null\n     * @return the date, time or date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u00272011-12-03\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE;\n    static {\n        ISO_LOCAL_DATE \u003d new DateTimeFormatterBuilder()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_MONTH, 2)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with an\n     * offset, such as \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE;\n    static {\n        ISO_OFFSET_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with the\n     * offset if available, such as \u00272011-12-03\u0027 or \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE;\n    static {\n        ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time without an\n     * offset, such as \u002710:15\u0027 or \u002710:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then the format is complete.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the nano-of-second is zero or not available then the format is complete.\n     * \u003cli\u003eA decimal point\n     * \u003cli\u003eOne to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.\n     *  As many digits will be output as required.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_TIME;\n    static {\n        ISO_LOCAL_TIME \u003d new DateTimeFormatterBuilder()\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalStart()\n                .appendFraction(NANO_OF_SECOND, 0, 9, true)\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time with an\n     * offset, such as \u002710:15+01:00\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_TIME;\n    static {\n        ISO_OFFSET_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time, with the\n     * offset if available, such as \u002710:15\u0027, \u002710:15:30\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_TIME;\n    static {\n        ISO_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time without\n     * an offset, such as \u00272011-12-03T10:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe letter \u0027T\u0027. Parsing is case insensitive.\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;\n    static {\n        ISO_LOCAL_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendLiteral(\u0027T\u0027)\n                .append(ISO_LOCAL_TIME)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time with an\n     * offset, such as \u00272011-12-03T10:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE_TIME;\n    static {\n        ISO_OFFSET_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE_TIME)\n                .parseLenient()\n                .appendOffsetId()\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * offset and zone, such as \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * a format that extends the ISO-8601 extended offset date-time format\n     * to add the time-zone.\n     * The section in square brackets is not part of the ISO-8601 standard.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME}\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ZONED_DATE_TIME;\n    static {\n        ISO_ZONED_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_OFFSET_DATE_TIME)\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * the offset and zone if available, such as \u00272011-12-03T10:15:30\u0027,\n     * \u00272011-12-03T10:15:30+01:00\u0027 or \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local or offset date-time format, as well as the\n     * extended non-ISO form specifying the time-zone.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE_TIME;\n    static {\n        ISO_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_LOCAL_DATE_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the ordinal date\n     * without an offset, such as \u00272012-337\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended ordinal date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThree digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ORDINAL_DATE;\n    static {\n        ISO_ORDINAL_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_YEAR, 3)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the week-based date\n     * without an offset, such as \u00272012-W48-6\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended week-based date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThe letter \u0027W\u0027. Parsing is case insensitive.\n     * \u003cli\u003eTwo digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eOne digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.\n     *  The value run from Monday (1) to Sunday (7).\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_WEEK_DATE;\n    static {\n        ISO_WEEK_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\"-W\")\n                .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_WEEK, 1)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO instant formatter that formats or parses an instant in UTC,\n     * such as \u00272011-12-03T10:15:30Z\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 instant format.\n     * When formatting, the second-of-minute is always output.\n     * The nano-of-second outputs zero, three, six or nine digits as necessary.\n     * When parsing, time to at least the seconds field is required.\n     * Fractional seconds from zero to nine are parsed.\n     * The localized decimal style is not used.\n     * \u003cp\u003e\n     * This is a special case formatter intended to allow a human readable form\n     * of an {@link java.time.Instant}. The {@code Instant} class is designed to\n     * only represent a point in time and internally stores a value in nanoseconds\n     * from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be\n     * formatted as a date or time without providing some form of time-zone.\n     * This formatter allows the {@code Instant} to be formatted, by providing\n     * a suitable conversion using {@code ZoneOffset.UTC}.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from\n     *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}\n     *  using the {@code UTC} offset. Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_INSTANT;\n    static {\n        ISO_INSTANT \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendInstant()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u002720111203\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 basic local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons. If the offset has\n     *  seconds then they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter BASIC_ISO_DATE;\n    static {\n        BASIC_ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendValue(DAY_OF_MONTH, 2)\n                .optionalStart()\n                .parseLenient()\n                .appendOffset(\"+HHMMss\", \"Z\")\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The RFC-1123 date-time formatter, such as \u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * most of the RFC-1123 format.\n     * RFC-1123 updates RFC-822 changing the year from two digits to four.\n     * This implementation requires a four digit year.\n     * This implementation also does not handle North American or military zone\n     * names, only \u0027GMT\u0027 and offset amounts.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eIf the day-of-week is not available to format or parse then jump to day-of-month.\n     * \u003cli\u003eThree letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.\n     * \u003cli\u003eA comma\n     * \u003cli\u003eA space\n     * \u003cli\u003eOne or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThree letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.\n     * \u003cli\u003eA space\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eA space\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then jump to the next space.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons or seconds.\n     *  An offset of zero uses \"GMT\". North American zone names and military zone names are not handled.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Parsing is case insensitive.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     */\n    public static final DateTimeFormatter RFC_1123_DATE_TIME;\n    static {\n        // manually code maps to ensure correct data always used\n        // (locale data can be changed by application code)\n        Map\u003cLong, String\u003e dow \u003d new HashMap\u003c\u003e();\n        dow.put(1L, \"Mon\");\n        dow.put(2L, \"Tue\");\n        dow.put(3L, \"Wed\");\n        dow.put(4L, \"Thu\");\n        dow.put(5L, \"Fri\");\n        dow.put(6L, \"Sat\");\n        dow.put(7L, \"Sun\");\n        Map\u003cLong, String\u003e moy \u003d new HashMap\u003c\u003e();\n        moy.put(1L, \"Jan\");\n        moy.put(2L, \"Feb\");\n        moy.put(3L, \"Mar\");\n        moy.put(4L, \"Apr\");\n        moy.put(5L, \"May\");\n        moy.put(6L, \"Jun\");\n        moy.put(7L, \"Jul\");\n        moy.put(8L, \"Aug\");\n        moy.put(9L, \"Sep\");\n        moy.put(10L, \"Oct\");\n        moy.put(11L, \"Nov\");\n        moy.put(12L, \"Dec\");\n        RFC_1123_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .parseLenient()\n                .optionalStart()\n                .appendText(DAY_OF_WEEK, dow)\n                .appendLiteral(\", \")\n                .optionalEnd()\n                .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE)\n                .appendLiteral(\u0027 \u0027)\n                .appendText(MONTH_OF_YEAR, moy)\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(YEAR, 4)  // 2 digit year not handled\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalEnd()\n                .appendLiteral(\u0027 \u0027)\n                .appendOffset(\"+HHMM\", \"GMT\")  // should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     * \u003cp\u003e\n     * There are two situations where this query may return a non-zero period.\n     * \u003cul\u003e\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code LENIENT} and a time is parsed\n     *  without a date, then the complete result of the parse consists of a\n     *  {@code LocalTime} and an excess {@code Period} in days.\n     *\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code SMART} and a time is parsed\n     *  without a date where the time is 24:00:00, then the complete result of\n     *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess\n     *  {@code Period} of one day.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     * \u003cp\u003e\n     * The {@code SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@code LENIENT} mode also produces the same result:\n     * \u003cpre\u003e\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * \u003c/pre\u003e\n     * The query can be used as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  LocalTime time \u003d parsed.query(LocalTime::from);\n     *  Period extraDays \u003d parsed.query(DateTimeFormatter.parsedExcessDays());\n     * \u003c/pre\u003e\n     * @return a query that provides access to the excess days that were parsed\n     */\n    public static final TemporalQuery\u003cPeriod\u003e parsedExcessDays() {\n        return PARSED_EXCESS_DAYS;\n    }\n    private static final TemporalQuery\u003cPeriod\u003e PARSED_EXCESS_DAYS \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    };\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     * \u003cp\u003e\n     * Instant parsing handles the special \"leap second\" time of \u002723:59:60\u0027.\n     * Leap seconds occur at \u002723:59:60\u0027 in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant()}, as that method\n     * always parses the instant with the UTC zone offset.\n     * \u003cp\u003e\n     * If the time \u002723:59:60\u0027 is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return {@code true} if it did adjust to remove the\n     * leap-second, and {@code false} if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  Instant instant \u003d parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * \u003c/pre\u003e\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    public static final TemporalQuery\u003cBoolean\u003e parsedLeapSecond() {\n        return PARSED_LEAP_SECOND;\n    }\n    private static final TemporalQuery\u003cBoolean\u003e PARSED_LEAP_SECOND \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).leapSecond;\n        } else {\n            return Boolean.FALSE;\n        }\n    };\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the DecimalStyle to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     */\n    DateTimeFormatter(CompositePrinterParser printerParser,\n            Locale locale, DecimalStyle decimalStyle,\n            ResolverStyle resolverStyle, Set\u003cTemporalField\u003e resolverFields,\n            Chronology chrono, ZoneId zone) {\n        this.printerParser \u003d Objects.requireNonNull(printerParser, \"printerParser\");\n        this.resolverFields \u003d resolverFields;\n        this.locale \u003d Objects.requireNonNull(locale, \"locale\");\n        this.decimalStyle \u003d Objects.requireNonNull(decimalStyle, \"decimalStyle\");\n        this.resolverStyle \u003d Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        this.chrono \u003d chrono;\n        this.zone \u003d zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the locale to be used during formatting.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public Locale getLocale() {\n        return locale;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new locale.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     * \u003cp\u003e\n     * The locale is stored as passed in, without further processing.\n     * If the locale has \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003e\n     * Unicode extensions\u003c/a\u003e, they may be used later in text\n     * processing. To set the chronology, time-zone and decimal style from\n     * unicode extensions, see {@link #localizedBy localizedBy()}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the new locale, not null\n     * @return a formatter based on this formatter with the requested locale, not null\n     * @see #localizedBy(Locale)\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with localized values of the locale,\n     * calendar, region, decimal style and/or timezone, that supercede values in\n     * this formatter.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern. If the locale contains the\n     * \"ca\" (calendar), \"nu\" (numbering system), \"rg\" (region override), and/or\n     * \"tz\" (timezone)\n     * \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003eUnicode extensions\u003c/a\u003e,\n     * the chronology, numbering system and/or the zone are overridden. If both \"ca\"\n     * and \"rg\" are specified, the chronology from the \"ca\" extension supersedes the\n     * implicit one from the \"rg\" extension. Same is true for the \"nu\" extension.\n     * \u003cp\u003e\n     * Unlike the {@link #withLocale withLocale} method, the call to this method may\n     * produce a different formatter depending on the order of method chaining with\n     * other withXXXX() methods.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the locale, not null\n     * @return a formatter based on this formatter with localized values of\n     *      the calendar, decimal style and/or timezone, that supercede values in this\n     *      formatter.\n     * @see #withLocale(Locale)\n     * @since 10\n     */\n    public DateTimeFormatter localizedBy(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n\n        // Check for decimalStyle/chronology/timezone in locale object\n        Chronology c \u003d locale.getUnicodeLocaleType(\"ca\") !\u003d null ?\n                       Chronology.ofLocale(locale) : chrono;\n        DecimalStyle ds \u003d locale.getUnicodeLocaleType(\"nu\") !\u003d null ?\n                       DecimalStyle.of(locale) : decimalStyle;\n        String tzType \u003d locale.getUnicodeLocaleType(\"tz\");\n        ZoneId z  \u003d tzType !\u003d null ?\n                    TimeZoneNameUtility.convertLDMLShortID(tzType)\n                        .map(ZoneId::of)\n                        .orElse(zone) :\n                    zone;\n        return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the DecimalStyle to be used during formatting.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public DecimalStyle getDecimalStyle() {\n        return decimalStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new DecimalStyle.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param decimalStyle  the new DecimalStyle, not null\n     * @return a formatter based on this formatter with the requested DecimalStyle, not null\n     */\n    public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle) {\n        if (this.decimalStyle.equals(decimalStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding chronology to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override chronology, used to convert dates.\n     * By default, a formatter has no override chronology, returning null.\n     * See {@link #withChronology(Chronology)} for more details on overriding.\n     *\n     * @return the override chronology of this formatter, null if no override\n     */\n    public Chronology getChronology() {\n        return chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any date that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains a date, then it will\n     * be converted to a date in the override chronology.\n     * Whether the temporal contains a date is determined by querying the\n     * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * Any time or zone will be retained unaltered unless overridden.\n     * \u003cp\u003e\n     * If the temporal object does not contain a date, but does contain one\n     * or more {@code ChronoField} date fields, then a {@code DateTimeException}\n     * is thrown. In all other cases, the override chronology is added to the temporal,\n     * replacing any previous chronology, but without changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a chronology has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then\n     * this override chronology has no effect.\n     * If no zone has been parsed, then this override chronology will be used\n     * to interpret the {@code ChronoField} values into a date according to the\n     * date resolving rules of the chronology.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, null if no override\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (Objects.equals(this.chrono, chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding zone to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override zone, used to convert instants.\n     * By default, a formatter has no override zone, returning null.\n     * See {@link #withZone(ZoneId)} for more details on overriding.\n     *\n     * @return the override zone of this formatter, null if no override\n     */\n    public ZoneId getZone() {\n        return zone;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override zone.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override zone set.\n     * By default, a formatter has no override zone, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any instant that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains an instant, then it will\n     * be converted to a zoned date-time using the override zone.\n     * Whether the temporal is an instant is determined by querying the\n     * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.\n     * If the input has a chronology then it will be retained unless overridden.\n     * If the input does not have a chronology, such as {@code Instant}, then\n     * the ISO chronology will be used.\n     * \u003cp\u003e\n     * If the temporal object does not contain an instant, but does contain\n     * an offset then an additional check is made. If the normalized override\n     * zone is an offset that differs from the offset of the temporal, then\n     * a {@code DateTimeException} is thrown. In all other cases, the override\n     * zone is added to the temporal, replacing any previous zone, but without\n     * changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a zone has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then\n     * this override zone has no effect.\n     * If no zone has been parsed, then this override zone will be included in\n     * the result of the parse where it can be used to build instants and date-times.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the new override zone, null if no override\n     * @return a formatter based on this formatter with the requested override zone, not null\n     */\n    public DateTimeFormatter withZone(ZoneId zone) {\n        if (Objects.equals(this.zone, zone)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver style to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver style, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.\n     * See {@link #withResolverStyle(ResolverStyle)} for more details.\n     *\n     * @return the resolver style of this formatter, not null\n     */\n    public ResolverStyle getResolverStyle() {\n        return resolverStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new resolver style.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the resolver style set. By default, a formatter has the\n     * {@link ResolverStyle#SMART SMART} resolver style.\n     * \u003cp\u003e\n     * Changing the resolver style only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver style is used to control how phase 2, resolving, happens.\n     * See {@code ResolverStyle} for more information on the options available.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverStyle  the new resolver style, not null\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle) {\n        Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        if (Objects.equals(this.resolverStyle, resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver fields to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver fields, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has no resolver fields, and thus returns null.\n     * See {@link #withResolverFields(Set)} for more details.\n     *\n     * @return the immutable set of resolver fields of this formatter, null if no fields\n     */\n    public Set\u003cTemporalField\u003e getResolverFields() {\n        return resolverFields;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(TemporalField... resolverFields) {\n        Set\u003cTemporalField\u003e fields \u003d null;\n        if (resolverFields !\u003d null) {\n            // Set.of cannot be used because it is hostile to nulls and duplicate elements\n            fields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(Arrays.asList(resolverFields)));\n        }\n        if (Objects.equals(this.resolverFields, fields)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(Set\u003cTemporalField\u003e resolverFields) {\n        if (Objects.equals(this.resolverFields, resolverFields)) {\n            return this;\n        }\n        if (resolverFields !\u003d null) {\n            resolverFields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(resolverFields));\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     * \u003cp\u003e\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @return the formatted string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public String format(TemporalAccessor temporal) {\n        StringBuilder buf \u003d new StringBuilder(32);\n        formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@code Appendable} using this formatter.\n     * \u003cp\u003e\n     * This outputs the formatted date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@code StringBuffer}, {@code StringBuilder},\n     * {@code PrintStream} and {@code Writer}.\n     * \u003cp\u003e\n     * Although {@code Appendable} methods throw an {@code IOException}, this method does not.\n     * Instead, any {@code IOException} is wrapped in a runtime exception.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @param appendable  the appendable to format to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public void formatTo(TemporalAccessor temporal, Appendable appendable) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        Objects.requireNonNull(appendable, \"appendable\");\n        try {\n            DateTimePrintContext context \u003d new DateTimePrintContext(temporal, this);\n            if (appendable instanceof StringBuilder) {\n                printerParser.format(context, (StringBuilder) appendable);\n            } else {\n                // buffer output to avoid writing to appendable in case of error\n                StringBuilder buf \u003d new StringBuilder(32);\n                printerParser.format(context, buf);\n                appendable.append(buf);\n            }\n        } catch (IOException ex) {\n            throw new DateTimeException(ex.getMessage(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing a temporal object.\n     * \u003cp\u003e\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parse(CharSequence text) {\n        Objects.requireNonNull(text, \"text\");\n        try {\n            return parseResolved0(text, null);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Parses the text using this formatter, providing control over the text position.\n     * \u003cp\u003e\n     * This parses the text without requiring the parse to start from the beginning\n     * of the string or finish at the end.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * The operation of this method is slightly different to similar methods using\n     * {@code ParsePosition} on {@code java.text.Format}. That class will return\n     * errors using the error index on the {@code ParsePosition}. By contrast, this\n     * method will throw a {@link DateTimeParseException} if an error occurs, with\n     * the exception containing the error index.\n     * This change in behavior is necessary due to the increased complexity of\n     * parsing and resolving dates/times in this API.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parse(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        try {\n            return parseResolved0(text, position);\n        } catch (DateTimeParseException | IndexOutOfBoundsException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing an object of the specified type.\n     * \u003cp\u003e\n     * Most applications should use this method for parsing.\n     * It parses the entire text to produce the required date-time.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * For example:\n     * \u003cpre\u003e\n     *  LocalDateTime dt \u003d parser.parse(str, LocalDateTime::from);\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param \u003cT\u003e the type of the parsed date-time\n     * @param text  the text to parse, not null\n     * @param query  the query defining the type to parse to, not null\n     * @return the parsed date-time, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public \u003cT\u003e T parse(CharSequence text, TemporalQuery\u003cT\u003e query) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(query, \"query\");\n        try {\n            return parseResolved0(text, null).query(query);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Fully parses the text producing an object of one of the specified types.\n     * \u003cp\u003e\n     * This parse method is convenient for use when the parser can handle optional elements.\n     * For example, a pattern of \u0027uuuu-MM-dd HH.mm[ VV]\u0027 can be fully parsed to a {@code ZonedDateTime},\n     * or partially parsed to a {@code LocalDateTime}.\n     * The queries must be specified in order, starting from the best matching full-parse option\n     * and ending with the worst matching minimal parse option.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * \u003cp\u003e\n     * The result is associated with the first type that successfully parses.\n     * Normally, applications will use {@code instanceof} to check the result.\n     * For example:\n     * \u003cpre\u003e\n     *  TemporalAccessor dt \u003d parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);\n     *  if (dt instanceof ZonedDateTime) {\n     *   ...\n     *  } else {\n     *   ...\n     *  }\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param queries  the queries defining the types to attempt to parse to,\n     *  must implement {@code TemporalAccessor}, not null\n     * @return the parsed date-time, not null\n     * @throws IllegalArgumentException if less than 2 types are specified\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parseBest(CharSequence text, TemporalQuery\u003c?\u003e... queries) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(queries, \"queries\");\n        if (queries.length \u003c 2) {\n            throw new IllegalArgumentException(\"At least two queries must be specified\");\n        }\n        try {\n            TemporalAccessor resolved \u003d parseResolved0(text, null);\n            for (TemporalQuery\u003c?\u003e query : queries) {\n                try {\n                    return (TemporalAccessor) resolved.query(query);\n                } catch (RuntimeException ex) {\n                    // continue\n                }\n            }\n            throw new DateTimeException(\"Unable to convert parsed text using any of the specified queries\");\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    private DateTimeParseException createError(CharSequence text, RuntimeException ex) {\n        String abbr;\n        if (text.length() \u003e 64) {\n            abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n        } else {\n            abbr \u003d text.toString();\n        }\n        return new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed: \" + ex.getMessage(), text, 0, ex);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses and resolves the specified text.\n     * \u003cp\u003e\n     * This parses to a {@code TemporalAccessor} ensuring that the text is fully parsed.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the resolved result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     * @throws DateTimeException if an error occurs while resolving the date or time\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {\n        ParsePosition pos \u003d (position !\u003d null ? position : new ParsePosition(0));\n        DateTimeParseContext context \u003d parseUnresolved0(text, pos);\n        if (context \u003d\u003d null || pos.getErrorIndex() \u003e\u003d 0 || (position \u003d\u003d null \u0026\u0026 pos.getIndex() \u003c text.length())) {\n            String abbr;\n            if (text.length() \u003e 64) {\n                abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n            } else {\n                abbr \u003d text.toString();\n            }\n            if (pos.getErrorIndex() \u003e\u003d 0) {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed at index \" +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed, unparsed text found at index \" +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return context.toResolved(resolverStyle, resolverFields);\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     * \u003cp\u003e\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n     * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     * \u003cp\u003e\n     * The result of this method is {@code TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of \u00272012-00-65\u0027 would result in a temporal with three fields - year of \u00272012\u0027,\n     * month of \u00270\u0027 and day-of-month of \u002765\u0027.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * Errors are returned using the error index field of the {@code ParsePosition}\n     * instead of {@code DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the result.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     * \u003cp\u003e\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position) {\n        DateTimeParseContext context \u003d parseUnresolved0(text, position);\n        if (context \u003d\u003d null) {\n            return null;\n        }\n        return context.toUnresolved();\n    }\n\n    private DateTimeParseContext parseUnresolved0(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        DateTimeParseContext context \u003d new DateTimeParseContext(this);\n        int pos \u003d position.getIndex();\n        pos \u003d printerParser.parse(context, text, pos);\n        if (pos \u003c 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param optional  whether the printer/parser should be optional\n     * @return the printer/parser, not null\n     */\n    CompositePrinterParser toPrinterParser(boolean optional) {\n        return printerParser.withOptional(optional);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to a resolved {@link TemporalAccessor}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat() {\n        return new ClassicFormat(this, null);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance that will\n     * parse using the specified query.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to the type specified.\n     * The type must be one that is supported by {@link #parse}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @param parseQuery  the query defining the type to parse to, not null\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat(TemporalQuery\u003c?\u003e parseQuery) {\n        Objects.requireNonNull(parseQuery, \"parseQuery\");\n        return new ClassicFormat(this, parseQuery);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a description of the underlying formatters.\n     *\n     * @return a description of this formatter, not null\n     */\n    @Override\n    public String toString() {\n        String pattern \u003d printerParser.toString();\n        pattern \u003d pattern.startsWith(\"[\") ? pattern : pattern.substring(1, pattern.length() - 1);\n        return pattern;\n        // TODO: Fix tests to not depend on toString()\n//        return \"DateTimeFormatter[\" + locale +\n//                (chrono !\u003d null ? \",\" + chrono : \"\") +\n//                (zone !\u003d null ? \",\" + zone : \"\") +\n//                pattern + \"]\";\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements the classic Java Format API.\n     * @serial exclude\n     */\n    @SuppressWarnings(\"serial\")  // not actually serializable\n    static class ClassicFormat extends Format {\n        /** The formatter. */\n        private final DateTimeFormatter formatter;\n        /** The type to be parsed. */\n        private final TemporalQuery\u003c?\u003e parseType;\n        /** Constructor. */\n        public ClassicFormat(DateTimeFormatter formatter, TemporalQuery\u003c?\u003e parseType) {\n            this.formatter \u003d formatter;\n            this.parseType \u003d parseType;\n        }\n\n        @Override\n        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n            Objects.requireNonNull(obj, \"obj\");\n            Objects.requireNonNull(toAppendTo, \"toAppendTo\");\n            Objects.requireNonNull(pos, \"pos\");\n            if (obj instanceof TemporalAccessor \u003d\u003d false) {\n                throw new IllegalArgumentException(\"Format target must implement TemporalAccessor\");\n            }\n            pos.setBeginIndex(0);\n            pos.setEndIndex(0);\n            try {\n                formatter.formatTo((TemporalAccessor) obj, toAppendTo);\n            } catch (RuntimeException ex) {\n                throw new IllegalArgumentException(ex.getMessage(), ex);\n            }\n            return toAppendTo;\n        }\n        @Override\n        public Object parseObject(String text) throws ParseException {\n            Objects.requireNonNull(text, \"text\");\n            try {\n                if (parseType \u003d\u003d null) {\n                    return formatter.parseResolved0(text, null);\n                }\n                return formatter.parse(text, parseType);\n            } catch (DateTimeParseException ex) {\n                throw new ParseException(ex.getMessage(), ex.getErrorIndex());\n            } catch (RuntimeException ex) {\n                throw (ParseException) new ParseException(ex.getMessage(), 0).initCause(ex);\n            }\n        }\n        @Override\n        public Object parseObject(String text, ParsePosition pos) {\n            Objects.requireNonNull(text, \"text\");\n            DateTimeParseContext context;\n            try {\n                context \u003d formatter.parseUnresolved0(text, pos);\n            } catch (IndexOutOfBoundsException ex) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            if (context \u003d\u003d null) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            try {\n                TemporalAccessor resolved \u003d context.toResolved(formatter.resolverStyle, formatter.resolverFields);\n                if (parseType \u003d\u003d null) {\n                    return resolved;\n                }\n                return resolved.query(parseType);\n            } catch (RuntimeException ex) {\n                pos.setErrorIndex(0);\n                return null;\n            }\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor25.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

nov. 07, 2024 11:11:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%25252B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25%2B9/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor29.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 198: jar:file:///C:/Users/User/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.25%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip/jdk-11.0.25 9/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.11.07 23:12:28 INFO  compiling root (1 scala source)
2024.11.07 23:12:29 INFO  time: compiled root in 1.16s
2024.11.07 23:12:36 INFO  compiling root (1 scala source)
2024.11.07 23:12:38 INFO  time: compiled root in 1.06s
2024.11.07 23:12:57 INFO  compiling root (1 scala source)
2024.11.07 23:12:58 INFO  time: compiled root in 1.08s
2024.11.07 23:24:30 INFO  compiling root (1 scala source)
2024.11.07 23:24:30 INFO  time: compiled root in 0.99s
2024.11.07 23:24:34 INFO  compiling root (1 scala source)
2024.11.07 23:24:34 INFO  time: compiled root in 0.84s
2024.11.07 23:25:08 INFO  compiling root (1 scala source)
2024.11.07 23:25:09 INFO  time: compiled root in 1.22s
2024.11.07 23:25:24 INFO  compiling root (1 scala source)
2024.11.07 23:25:25 INFO  time: compiled root in 1.34s
2024.11.07 23:25:38 INFO  compiling root (1 scala source)
2024.11.07 23:25:38 INFO  time: compiled root in 0.2s
2024.11.07 23:25:46 INFO  compiling root (1 scala source)
2024.11.07 23:25:46 INFO  time: compiled root in 0.78s
2024.11.07 23:26:27 INFO  compiling root (1 scala source)
2024.11.07 23:26:27 INFO  time: compiled root in 0.28s
2024.11.07 23:26:42 INFO  compiling root (1 scala source)
2024.11.07 23:26:42 INFO  time: compiled root in 0.24s
nov. 07, 2024 11:27:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5767
nov. 07, 2024 11:27:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5788
2024.11.07 23:27:14 INFO  compiling root (1 scala source)
2024.11.07 23:27:14 INFO  time: compiled root in 0.79s
2024.11.07 23:28:32 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals17572723836800966478\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:28:34 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:28:34 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:28:36 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:28:37 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:28:37 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:28:40 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:28:40 INFO  [success] Total time: 3 s, completed 7 de nov de 2024 23:28:40
2024.11.07 23:28:44 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 23:28:44 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 23:28:48 INFO  [success] Generated .bloop\root-test.json
2024.11.07 23:28:48 INFO  [success] Generated .bloop\root.json
2024.11.07 23:28:48 INFO  [success] Total time: 4 s, completed 7 de nov de 2024 23:28:48
2024.11.07 23:28:48 INFO  time: ran 'sbt bloopInstall' in 15s
2024.11.07 23:28:48 INFO  Disconnecting from Bloop session...
2024.11.07 23:28:48 INFO  Shut down connection with build server.
2024.11.07 23:28:48 INFO  Shut down connection with build server.
2024.11.07 23:28:48 INFO  Attempting to connect to the build server...
2024.11.07 23:28:48 INFO  Found a Bloop server running
2024.11.07 23:28:48 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:28:48 INFO  Attempting to connect to the build server...
2024.11.07 23:28:48 INFO  Found a Bloop server running
2024.11.07 23:28:48 WARN  no build target for: C:\Users\User\hotel-bookinghotel-booking\build.sbt
2024.11.07 23:28:48 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:28:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:28:49 INFO  time: Connected to build server in 1.17s
2024.11.07 23:28:49 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:28:49 INFO  running doctor check
2024.11.07 23:28:49 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:28:52 INFO  time: indexed workspace in 2.51s
2024.11.07 23:28:52 INFO  compiling root (2 scala sources)
2024.11.07 23:28:52 INFO  time: compiled root in 0.22s
2024.11.07 23:28:52 INFO  skipping build import with status 'Installed'
2024.11.07 23:28:52 INFO  Disconnecting from Bloop session...
2024.11.07 23:28:52 INFO  Shut down connection with build server.
2024.11.07 23:28:52 INFO  Shut down connection with build server.
nov. 07, 2024 11:28:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
ADVERTÊNCIA: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.io.IOException: Connection reset by peer
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:135)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:191)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:160)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.$anonfun$cancel$1(FutureWithTimeout.scala:37)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:217)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.cancel(FutureWithTimeout.scala:37)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:457)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:183)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:175)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.io.IOException: Connection reset by peer
	at java.base/sun.nio.ch.SocketDispatcher.write0(Native Method)
	at java.base/sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:54)
	at java.base/sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:132)
	at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:97)
	at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:53)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:532)
	at java.base/java.nio.channels.Channels.writeFullyImpl(Channels.java:74)
	at java.base/java.nio.channels.Channels.writeFully(Channels.java:93)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:171)
	at java.base/java.io.OutputStream.write(OutputStream.java:127)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:151)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:137)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:108)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

2024.11.07 23:28:52 INFO  Scala test classes not supported by server
2024.11.07 23:28:52 INFO  Attempting to connect to the build server...
2024.11.07 23:28:52 INFO  Found a Bloop server running
2024.11.07 23:28:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:28:52 INFO  Attempting to connect to the build server...
2024.11.07 23:28:52 INFO  Found a Bloop server running
2024.11.07 23:28:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:28:53 INFO  time: Connected to build server in 1.16s
2024.11.07 23:28:53 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:28:53 INFO  running doctor check
2024.11.07 23:28:53 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:28:55 INFO  time: indexed workspace in 2.03s
2024.11.07 23:28:55 INFO  compiling root (2 scala sources)
2024.11.07 23:28:55 INFO  time: compiled root in 0.17s
2024.11.07 23:29:05 INFO  compiling root (2 scala sources)
2024.11.07 23:29:05 INFO  time: compiled root in 0.19s
2024.11.07 23:29:05 INFO  compiling root (2 scala sources)
2024.11.07 23:29:05 INFO  time: compiled root in 87ms
2024.11.07 23:29:09 INFO  compiling root (3 scala sources)
2024.11.07 23:29:09 INFO  time: compiled root in 0.32s
2024.11.07 23:29:23 INFO  compiling root (3 scala sources)
2024.11.07 23:29:23 INFO  time: compiled root in 0.19s
2024.11.07 23:29:26 INFO  compiling root (4 scala sources)
2024.11.07 23:29:26 INFO  time: compiled root in 0.54s
2024.11.07 23:29:47 INFO  compiling root (4 scala sources)
2024.11.07 23:29:47 INFO  time: compiled root in 0.25s
2024.11.07 23:29:50 INFO  compiling root (5 scala sources)
2024.11.07 23:29:50 INFO  time: compiled root in 0.47s
2024.11.07 23:30:06 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.07 23:30:06 INFO  no build target found for /slick/jdbc/JdbcProfile.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.07 23:30:43 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals10651100876726844295\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:30:45 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:30:45 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:30:46 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:30:46 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:30:46 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:30:49 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:30:49 INFO  [success] Total time: 2 s, completed 7 de nov de 2024 23:30:50
2024.11.07 23:30:52 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 23:30:52 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 23:30:52 INFO  [success] Generated .bloop\root.json
2024.11.07 23:30:52 INFO  [success] Generated .bloop\root-test.json
2024.11.07 23:30:52 INFO  [success] Total time: 1 s, completed 7 de nov de 2024 23:30:53
2024.11.07 23:30:53 INFO  time: ran 'sbt bloopInstall' in 10s
2024.11.07 23:30:53 INFO  Disconnecting from Bloop session...
2024.11.07 23:30:53 INFO  Shut down connection with build server.
2024.11.07 23:30:53 INFO  Shut down connection with build server.
2024.11.07 23:30:53 INFO  Attempting to connect to the build server...
2024.11.07 23:30:53 INFO  Found a Bloop server running
2024.11.07 23:30:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:30:54 INFO  Attempting to connect to the build server...
2024.11.07 23:30:54 INFO  Found a Bloop server running
2024.11.07 23:30:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:30:53 INFO  time: Connected to build server in 0.99s
2024.11.07 23:30:53 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:30:54 INFO  running doctor check
2024.11.07 23:30:54 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:30:56 INFO  time: indexed workspace in 1.91s
2024.11.07 23:30:56 INFO  compiling root (3 scala sources)
2024.11.07 23:30:56 INFO  time: compiled root in 0.33s
2024.11.07 23:31:07 INFO  skipping build import with status 'Installed'
2024.11.07 23:31:07 INFO  Disconnecting from Bloop session...
2024.11.07 23:31:07 INFO  Shut down connection with build server.
2024.11.07 23:31:07 INFO  Scala main classes not supported by server
2024.11.07 23:31:07 INFO  Shut down connection with build server.
2024.11.07 23:31:07 INFO  Cancelling compilation on Bloop server
2024.11.07 23:31:07 INFO  Attempting to connect to the build server...
2024.11.07 23:31:07 INFO  Found a Bloop server running
2024.11.07 23:31:07 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:31:08 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:31:07 INFO  Attempting to connect to the build server...
2024.11.07 23:31:07 INFO  Found a Bloop server running
2024.11.07 23:31:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:31:07 INFO  time: Connected to build server in 0.9s
2024.11.07 23:31:07 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:31:07 INFO  running doctor check
2024.11.07 23:31:07 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:31:10 INFO  time: indexed workspace in 1.64s
2024.11.07 23:31:10 INFO  compiling root (3 scala sources)
2024.11.07 23:31:10 INFO  time: compiled root in 0.26s
nov. 07, 2024 11:31:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6005
2024.11.07 23:31:42 INFO  skipping build import with status 'Installed'
2024.11.07 23:31:42 INFO  Disconnecting from Bloop session...
2024.11.07 23:31:42 INFO  Cancelling compilation on Bloop server
2024.11.07 23:31:42 INFO  Shut down connection with build server.
2024.11.07 23:31:42 INFO  Shut down connection with build server.
2024.11.07 23:31:42 INFO  Attempting to connect to the build server...
2024.11.07 23:31:42 INFO  Found a Bloop server running
2024.11.07 23:31:42 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:31:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:31:42 INFO  Attempting to connect to the build server...
2024.11.07 23:31:42 INFO  Found a Bloop server running
2024.11.07 23:31:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:31:43 INFO  time: Connected to build server in 0.93s
2024.11.07 23:31:43 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:31:43 INFO  running doctor check
2024.11.07 23:31:43 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:31:45 INFO  time: indexed workspace in 1.78s
2024.11.07 23:31:45 INFO  compiling root (3 scala sources)
2024.11.07 23:31:45 INFO  time: compiled hotel-bookinghotel-booking-build in 63ms
2024.11.07 23:31:45 INFO  time: compiled root in 0.34s
2024.11.07 23:31:46 INFO  compiling root (3 scala sources)
2024.11.07 23:31:46 INFO  time: compiled root in 0.29s
2024.11.07 23:33:02 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals13531069137707530478\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:33:04 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:33:04 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:33:06 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:33:06 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:33:07 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:33:09 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:33:09 INFO  [success] Total time: 3 s, completed 7 de nov de 2024 23:33:10
2024.11.07 23:33:14 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 23:33:14 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 23:33:19 INFO  [success] Generated .bloop\root.json
2024.11.07 23:33:19 INFO  [success] Generated .bloop\root-test.json
2024.11.07 23:33:19 INFO  [success] Total time: 5 s, completed 7 de nov de 2024 23:33:19
2024.11.07 23:33:19 INFO  time: ran 'sbt bloopInstall' in 16s
2024.11.07 23:33:19 INFO  Disconnecting from Bloop session...
2024.11.07 23:33:19 INFO  Shut down connection with build server.
2024.11.07 23:33:19 INFO  Shut down connection with build server.
2024.11.07 23:33:19 INFO  Attempting to connect to the build server...
2024.11.07 23:33:19 INFO  Found a Bloop server running
2024.11.07 23:33:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:33:19 INFO  Attempting to connect to the build server...
2024.11.07 23:33:19 INFO  Found a Bloop server running
2024.11.07 23:33:20 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:33:20 INFO  time: Connected to build server in 1s
2024.11.07 23:33:20 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:33:20 INFO  running doctor check
2024.11.07 23:33:20 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:33:23 INFO  time: indexed workspace in 2.98s
2024.11.07 23:33:26 INFO  compiling root (3 scala sources)
2024.11.07 23:33:26 INFO  time: compiled root in 0.29s
2024.11.07 23:33:28 INFO  skipping build import with status 'Installed'
2024.11.07 23:33:28 INFO  Disconnecting from Bloop session...
2024.11.07 23:33:28 INFO  Cancelling compilation on Bloop server
2024.11.07 23:33:28 INFO  Shut down connection with build server.
2024.11.07 23:33:28 INFO  Shut down connection with build server.
2024.11.07 23:33:28 INFO  Scala test classes not supported by server
2024.11.07 23:33:28 INFO  Scala main classes not supported by server
2024.11.07 23:33:28 INFO  Attempting to connect to the build server...
2024.11.07 23:33:28 INFO  Found a Bloop server running
2024.11.07 23:33:28 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:33:29 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:33:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:33:28 INFO  Attempting to connect to the build server...
2024.11.07 23:33:28 INFO  Found a Bloop server running
2024.11.07 23:33:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:33:29 INFO  time: Connected to build server in 0.91s
2024.11.07 23:33:29 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:33:29 INFO  running doctor check
2024.11.07 23:33:29 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:33:31 INFO  time: indexed workspace in 1.73s
2024.11.07 23:33:31 INFO  time: compiled hotel-bookinghotel-booking-build in 8ms
2024.11.07 23:33:31 INFO  compiling root (3 scala sources)
2024.11.07 23:33:31 INFO  time: compiled root in 0.3s
2024.11.07 23:33:37 INFO  compiling root (3 scala sources)
2024.11.07 23:33:37 INFO  time: compiled root in 0.29s
2024.11.07 23:33:48 INFO  compiling root (3 scala sources)
2024.11.07 23:33:48 INFO  time: compiled root in 0.25s
2024.11.07 23:34:02 INFO  compiling root (3 scala sources)
2024.11.07 23:34:02 INFO  time: compiled root in 0.26s
2024.11.07 23:34:07 INFO  compiling root (3 scala sources)
2024.11.07 23:34:07 INFO  time: compiled root in 0.27s
2024.11.07 23:34:59 INFO  compiling root (3 scala sources)
2024.11.07 23:34:59 INFO  time: compiled root in 0.3s
2024.11.07 23:35:15 INFO  skipping build import with status 'Installed'
2024.11.07 23:35:15 INFO  Disconnecting from Bloop session...
2024.11.07 23:35:15 INFO  Cancelling compilation on Bloop server
2024.11.07 23:35:15 INFO  Shut down connection with build server.
2024.11.07 23:35:15 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:35:15 INFO  Shut down connection with build server.
2024.11.07 23:35:15 INFO  Attempting to connect to the build server...
2024.11.07 23:35:15 INFO  Found a Bloop server running
2024.11.07 23:35:15 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:35:16 INFO  Attempting to connect to the build server...
2024.11.07 23:35:16 INFO  Found a Bloop server running
2024.11.07 23:35:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:35:16 INFO  time: Connected to build server in 1s
2024.11.07 23:35:16 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:35:16 INFO  running doctor check
2024.11.07 23:35:16 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:35:18 INFO  time: indexed workspace in 1.91s
2024.11.07 23:35:18 INFO  compiling root (3 scala sources)
2024.11.07 23:35:18 INFO  time: compiled hotel-bookinghotel-booking-build in 61ms
2024.11.07 23:35:18 INFO  time: compiled root in 0.24s
2024.11.07 23:35:21 INFO  skipping build import with status 'Installed'
2024.11.07 23:35:21 INFO  Disconnecting from Bloop session...
2024.11.07 23:35:21 INFO  Cancelling compilation on Bloop server
2024.11.07 23:35:21 INFO  Shut down connection with build server.
2024.11.07 23:35:21 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:35:21 INFO  Shut down connection with build server.
2024.11.07 23:35:21 INFO  Attempting to connect to the build server...
2024.11.07 23:35:21 INFO  Found a Bloop server running
2024.11.07 23:35:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:35:21 INFO  Attempting to connect to the build server...
2024.11.07 23:35:21 INFO  Found a Bloop server running
2024.11.07 23:35:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:35:22 INFO  time: Connected to build server in 0.93s
2024.11.07 23:35:22 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:35:21 INFO  running doctor check
2024.11.07 23:35:21 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:35:24 INFO  time: indexed workspace in 1.76s
2024.11.07 23:35:24 INFO  compiling root (3 scala sources)
2024.11.07 23:35:24 INFO  time: compiled hotel-bookinghotel-booking-build in 64ms
2024.11.07 23:35:24 INFO  time: compiled root in 0.27s
2024.11.07 23:35:24 INFO  compiling root (3 scala sources)
2024.11.07 23:35:25 INFO  time: compiled root in 0.23s
2024.11.07 23:35:30 INFO  compiling root (3 scala sources)
2024.11.07 23:35:30 INFO  time: compiled root in 0.24s
2024.11.07 23:36:23 INFO  compiling root (3 scala sources)
2024.11.07 23:36:23 INFO  time: compiled root in 0.27s
2024.11.07 23:37:05 INFO  compiling root (3 scala sources)
2024.11.07 23:37:05 INFO  time: compiled root in 0.27s
2024.11.07 23:37:09 INFO  compiling root (3 scala sources)
2024.11.07 23:37:10 INFO  time: compiled root in 1.18s
2024.11.07 23:37:49 INFO  compiling root (1 scala source)
2024.11.07 23:37:49 INFO  time: compiled root in 0.83s
2024.11.07 23:38:24 INFO  compiling root (1 scala source)
2024.11.07 23:38:24 INFO  time: compiled root in 0.21s
2024.11.07 23:38:32 INFO  compiling root (1 scala source)
2024.11.07 23:38:32 INFO  time: compiled root in 0.75s
2024.11.07 23:39:11 INFO  compiling root (1 scala source)
2024.11.07 23:39:11 INFO  time: compiled root in 0.77s
2024.11.07 23:41:07 INFO  skipping build import with status 'Installed'
2024.11.07 23:41:07 INFO  Disconnecting from Bloop session...
2024.11.07 23:41:07 INFO  Shut down connection with build server.
2024.11.07 23:41:07 INFO  Cancelling compilation on Bloop server
2024.11.07 23:41:07 INFO  Shut down connection with build server.
2024.11.07 23:41:07 INFO  Scala test classes not supported by server
2024.11.07 23:41:07 INFO  Attempting to connect to the build server...
2024.11.07 23:41:07 INFO  Scala main classes not supported by server
2024.11.07 23:41:07 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:41:07 INFO  Found a Bloop server running
2024.11.07 23:41:07 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:41:08 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:41:08 INFO  Attempting to connect to the build server...
2024.11.07 23:41:08 INFO  Found a Bloop server running
2024.11.07 23:41:08 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:41:08 INFO  time: Connected to build server in 0.92s
2024.11.07 23:41:08 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:41:07 INFO  running doctor check
2024.11.07 23:41:07 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:41:10 INFO  time: indexed workspace in 2.16s
2024.11.07 23:41:10 INFO  time: compiled hotel-bookinghotel-booking-build in 13ms
2024.11.07 23:41:10 INFO  time: compiled root-test in 38ms
2024.11.07 23:41:32 INFO  compiling root (1 scala source)
2024.11.07 23:41:32 INFO  time: compiled root in 0.72s
2024.11.07 23:42:12 INFO  compiling root (1 scala source)
2024.11.07 23:42:12 INFO  time: compiled root in 0.31s
2024.11.07 23:42:15 INFO  compiling root (1 scala source)
2024.11.07 23:42:15 INFO  time: compiled root in 0.3s
2024.11.07 23:42:19 INFO  compiling root (1 scala source)
2024.11.07 23:42:19 INFO  time: compiled root in 0.14s
2024.11.07 23:42:20 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:42:34 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:42:34 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:42:35 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:42:43 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:43:18 INFO  skipping build import with status 'Installed'
2024.11.07 23:43:18 INFO  Disconnecting from Bloop session...
2024.11.07 23:43:18 INFO  Cancelling compilation on Bloop server
2024.11.07 23:43:18 INFO  Shut down connection with build server.
2024.11.07 23:43:18 INFO  Shut down connection with build server.
2024.11.07 23:43:18 INFO  Scala test classes not supported by server
2024.11.07 23:43:18 INFO  Scala main classes not supported by server
2024.11.07 23:43:18 INFO  Attempting to connect to the build server...
2024.11.07 23:43:18 INFO  Found a Bloop server running
2024.11.07 23:43:18 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:43:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:43:18 INFO  Attempting to connect to the build server...
2024.11.07 23:43:18 INFO  Found a Bloop server running
2024.11.07 23:43:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:43:19 INFO  time: Connected to build server in 0.95s
2024.11.07 23:43:19 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:43:19 INFO  running doctor check
2024.11.07 23:43:19 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:43:21 INFO  time: indexed workspace in 1.97s
2024.11.07 23:43:21 INFO  compiling root (1 scala source)
2024.11.07 23:43:21 INFO  time: compiled hotel-bookinghotel-booking-build in 58ms
2024.11.07 23:43:21 INFO  time: compiled root in 0.17s
2024.11.07 23:43:25 INFO  compiling root (1 scala source)
2024.11.07 23:43:25 INFO  time: compiled root in 0.16s
2024.11.07 23:43:26 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:06 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:12 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:17 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:52 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:53 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:55 INFO  compiling root (1 scala source)
2024.11.07 23:44:55 INFO  time: compiled root in 0.15s
2024.11.07 23:44:55 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:44:56 INFO  compiling root (1 scala source)
2024.11.07 23:44:56 INFO  time: compiled root in 0.16s
2024.11.07 23:44:57 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:45:01 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:21 INFO  compiling root (1 scala source)
2024.11.07 23:46:21 INFO  time: compiled root in 0.24s
2024.11.07 23:46:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:21 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:22 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:23 INFO  compiling root (1 scala source)
2024.11.07 23:46:23 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:23 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:23 INFO  time: compiled root in 0.15s
2024.11.07 23:46:23 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:35 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:39 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:40 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:43 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:44 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:45 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:50 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:50 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:50 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:50 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:50 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:50 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:51 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:51 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
nov. 07, 2024 11:46:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6826
2024.11.07 23:46:52 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:52 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:53 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:46:53 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:47:07 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:47:08 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:48:09 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals480955053573896270\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:48:11 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:48:11 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:48:12 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:48:12 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:48:13 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:48:15 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:48:15 INFO  [success] Total time: 2 s, completed 7 de nov de 2024 23:48:16
2024.11.07 23:48:19 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 23:48:19 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 23:48:24 INFO  [success] Generated .bloop\root.json
2024.11.07 23:48:24 INFO  [success] Generated .bloop\root-test.json
2024.11.07 23:48:24 INFO  [success] Total time: 5 s, completed 7 de nov de 2024 23:48:24
2024.11.07 23:48:24 INFO  time: ran 'sbt bloopInstall' in 15s
2024.11.07 23:48:24 INFO  Disconnecting from Bloop session...
2024.11.07 23:48:24 INFO  Shut down connection with build server.
2024.11.07 23:48:24 INFO  Shut down connection with build server.
2024.11.07 23:48:24 INFO  Attempting to connect to the build server...
2024.11.07 23:48:24 INFO  Found a Bloop server running
2024.11.07 23:48:24 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:48:25 INFO  Attempting to connect to the build server...
2024.11.07 23:48:25 INFO  Found a Bloop server running
2024.11.07 23:48:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:48:26 INFO  time: Connected to build server in 1.03s
2024.11.07 23:48:26 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:48:26 INFO  running doctor check
2024.11.07 23:48:26 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:48:29 INFO  time: indexed workspace in 3.32s
2024.11.07 23:48:29 INFO  Deduplicating compilation of root from bsp client 'Metals 1.4.0' (since 4.091s)
2024.11.07 23:48:29 INFO  compiling root (1 scala source)
2024.11.07 23:48:29 INFO  compiling root (1 scala source)
2024.11.07 23:48:29 INFO  time: compiled root in 0.18s
2024.11.07 23:48:29 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:48:30 WARN  Could not load snapshot text for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\services\ReservationServiceTest.scala
2024.11.07 23:48:34 INFO  compiling root (1 scala source)
2024.11.07 23:48:34 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.07 23:48:34 INFO  time: compiled root in 0.19s
2024.11.07 23:48:34 INFO  compiling root (1 scala source)
2024.11.07 23:48:34 INFO  time: compiled root in 0.14s
2024.11.07 23:48:41 INFO  compiling root (1 scala source)
2024.11.07 23:48:41 INFO  time: compiled root in 0.14s
2024.11.07 23:49:18 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals6871844635548481599\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:49:20 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:49:20 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:49:22 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:49:22 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:49:22 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:49:25 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:49:25 INFO  [success] Total time: 2 s, completed 7 de nov de 2024 23:49:25
2024.11.07 23:49:27 ERROR C:\Users\User\hotel-bookinghotel-booking\build.sbt:9: error: No Append.Values[Seq[sbt.librarymanagement.ModuleID], Seq[Object]] found, so Seq[Object] cannot be appended to Seq[sbt.librarymanagement.ModuleID]
2024.11.07 23:49:27 ERROR     libraryDependencies ++= Seq(
2024.11.07 23:49:27 ERROR                         ^
2024.11.07 23:49:27 ERROR sbt.compiler.EvalException: Type error in expression
2024.11.07 23:49:27 INFO  [error] sbt.compiler.EvalException: Type error in expression
2024.11.07 23:49:27 INFO  [error] Use 'last' for the full log.
2024.11.07 23:49:27 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.11.07 23:49:27 INFO  time: ran 'sbt bloopInstall' in 8.31s
2024.11.07 23:49:27 ERROR sbt command failed: C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals6871844635548481599\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.11.07 23:49:27 INFO  Disconnecting from Bloop session...
2024.11.07 23:49:27 INFO  Shut down connection with build server.
2024.11.07 23:49:27 INFO  Shut down connection with build server.
2024.11.07 23:49:27 INFO  Attempting to connect to the build server...
2024.11.07 23:49:27 INFO  Found a Bloop server running
2024.11.07 23:49:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:49:27 INFO  Attempting to connect to the build server...
2024.11.07 23:49:27 INFO  Found a Bloop server running
2024.11.07 23:49:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:49:27 INFO  time: Connected to build server in 0.99s
2024.11.07 23:49:27 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:49:27 INFO  running doctor check
2024.11.07 23:49:27 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:49:30 INFO  time: indexed workspace in 2.1s
2024.11.07 23:49:30 INFO  compiling root (1 scala source)
2024.11.07 23:49:30 INFO  time: compiled root in 0.17s
2024.11.07 23:49:44 INFO  skipping build import with status 'Installed'
2024.11.07 23:49:44 INFO  Disconnecting from Bloop session...
2024.11.07 23:49:44 INFO  Cancelling compilation on Bloop server
2024.11.07 23:49:44 INFO  Shut down connection with build server.
2024.11.07 23:49:44 INFO  Shut down connection with build server.
2024.11.07 23:49:44 INFO  Scala main classes not supported by server
2024.11.07 23:49:44 INFO  Scala test classes not supported by server
2024.11.07 23:49:44 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:49:44 INFO  Attempting to connect to the build server...
2024.11.07 23:49:44 INFO  Found a Bloop server running
2024.11.07 23:49:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:49:44 INFO  Attempting to connect to the build server...
2024.11.07 23:49:44 INFO  Found a Bloop server running
2024.11.07 23:49:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:49:44 INFO  time: Connected to build server in 0.91s
2024.11.07 23:49:44 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:49:44 INFO  running doctor check
2024.11.07 23:49:44 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:49:47 INFO  time: indexed workspace in 1.74s
2024.11.07 23:49:47 INFO  compiling root (1 scala source)
2024.11.07 23:49:47 INFO  time: compiled hotel-bookinghotel-booking-build in 63ms
2024.11.07 23:49:47 INFO  time: compiled root in 0.15s
2024.11.07 23:49:50 INFO  compiling root (1 scala source)
2024.11.07 23:49:50 INFO  time: compiled root in 0.17s
2024.11.07 23:49:58 INFO  compiling root (1 scala source)
2024.11.07 23:49:58 INFO  time: compiled root in 0.14s
2024.11.07 23:51:34 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals4115787409866831520\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:51:36 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:51:36 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:51:37 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:51:37 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:51:38 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:51:40 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:51:40 INFO  [success] Total time: 2 s, completed 7 de nov de 2024 23:51:41
2024.11.07 23:51:44 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 23:51:44 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 23:51:48 INFO  [success] Generated .bloop\root.json
2024.11.07 23:51:48 INFO  [success] Generated .bloop\root-test.json
2024.11.07 23:51:48 INFO  [success] Total time: 4 s, completed 7 de nov de 2024 23:51:48
2024.11.07 23:51:49 INFO  time: ran 'sbt bloopInstall' in 14s
2024.11.07 23:51:49 INFO  Disconnecting from Bloop session...
2024.11.07 23:51:49 INFO  Shut down connection with build server.
2024.11.07 23:51:49 INFO  Shut down connection with build server.
2024.11.07 23:51:49 INFO  Attempting to connect to the build server...
2024.11.07 23:51:49 INFO  Found a Bloop server running
2024.11.07 23:51:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:51:49 INFO  Attempting to connect to the build server...
2024.11.07 23:51:49 INFO  Found a Bloop server running
2024.11.07 23:51:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:51:49 INFO  time: Connected to build server in 0.98s
2024.11.07 23:51:49 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:51:50 INFO  running doctor check
2024.11.07 23:51:50 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:51:52 INFO  time: indexed workspace in 2.11s
2024.11.07 23:51:52 INFO  compiling root (1 scala source)
2024.11.07 23:51:52 INFO  time: compiled root in 0.17s
2024.11.07 23:51:58 INFO  compiling root (1 scala source)
2024.11.07 23:51:58 INFO  time: compiled root in 0.16s
2024.11.07 23:52:00 INFO  compiling root (1 scala source)
2024.11.07 23:52:00 INFO  time: compiled root in 0.14s
nov. 07, 2024 11:52:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7059
2024.11.07 23:52:20 INFO  compiling root (1 scala source)
2024.11.07 23:52:20 INFO  time: compiled root in 0.14s
2024.11.07 23:52:25 INFO  compiling root (1 scala source)
2024.11.07 23:52:25 INFO  time: compiled root in 0.14s
2024.11.07 23:53:11 INFO  compiling root (1 scala source)
2024.11.07 23:53:11 INFO  time: compiled root in 0.21s
2024.11.07 23:53:13 INFO  compiling root (1 scala source)
2024.11.07 23:53:13 INFO  time: compiled root in 0.14s
2024.11.07 23:53:37 INFO  compiling root (1 scala source)
2024.11.07 23:53:37 INFO  time: compiled root in 0.14s
2024.11.07 23:53:43 INFO  compiling root (1 scala source)
2024.11.07 23:53:43 INFO  time: compiled root in 0.14s
2024.11.07 23:54:18 INFO  compiling root (1 scala source)
2024.11.07 23:54:18 INFO  time: compiled root in 0.16s
2024.11.07 23:56:09 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals2098029493091226426\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:56:11 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:56:11 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:56:12 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:56:13 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:56:13 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:56:16 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:56:16 INFO  [success] Total time: 3 s, completed 7 de nov de 2024 23:56:16
2024.11.07 23:56:19 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 23:56:19 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 23:56:20 INFO  [success] Generated .bloop\root-test.json
2024.11.07 23:56:20 INFO  [success] Generated .bloop\root.json
2024.11.07 23:56:20 INFO  [success] Total time: 1 s, completed 7 de nov de 2024 23:56:21
2024.11.07 23:56:21 INFO  time: ran 'sbt bloopInstall' in 11s
2024.11.07 23:56:21 INFO  Disconnecting from Bloop session...
2024.11.07 23:56:21 INFO  Shut down connection with build server.
2024.11.07 23:56:21 INFO  Shut down connection with build server.
2024.11.07 23:56:21 INFO  Attempting to connect to the build server...
2024.11.07 23:56:21 INFO  Found a Bloop server running
2024.11.07 23:56:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:56:21 INFO  Attempting to connect to the build server...
2024.11.07 23:56:21 INFO  Found a Bloop server running
2024.11.07 23:56:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:56:21 INFO  time: Connected to build server in 0.98s
2024.11.07 23:56:21 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:56:21 INFO  running doctor check
2024.11.07 23:56:21 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:56:24 INFO  time: indexed workspace in 2.19s
2024.11.07 23:56:24 INFO  compiling root (1 scala source)
2024.11.07 23:56:24 INFO  time: compiled root in 0.17s
2024.11.07 23:57:05 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals9901116219666089799\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.07 23:57:07 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.07 23:57:07 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.07 23:57:08 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.07 23:57:08 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.07 23:57:09 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.07 23:57:11 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.07 23:57:11 INFO  [success] Total time: 3 s, completed 7 de nov de 2024 23:57:12
2024.11.07 23:57:15 INFO  [info] loading settings for project root from build.sbt ...
2024.11.07 23:57:15 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.07 23:57:21 INFO  [success] Generated .bloop\root.json
2024.11.07 23:57:21 INFO  [success] Generated .bloop\root-test.json
2024.11.07 23:57:21 INFO  [success] Total time: 6 s, completed 7 de nov de 2024 23:57:21
2024.11.07 23:57:21 INFO  time: ran 'sbt bloopInstall' in 16s
2024.11.07 23:57:21 INFO  Disconnecting from Bloop session...
2024.11.07 23:57:21 INFO  Shut down connection with build server.
2024.11.07 23:57:21 INFO  Shut down connection with build server.
2024.11.07 23:57:21 INFO  Attempting to connect to the build server...
2024.11.07 23:57:21 INFO  Found a Bloop server running
2024.11.07 23:57:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:57:22 INFO  Attempting to connect to the build server...
2024.11.07 23:57:22 INFO  Found a Bloop server running
2024.11.07 23:57:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:57:22 INFO  time: Connected to build server in 0.96s
2024.11.07 23:57:22 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:57:22 INFO  running doctor check
2024.11.07 23:57:22 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:57:25 INFO  time: indexed workspace in 2.92s
2024.11.07 23:57:25 INFO  compiling root (1 scala source)
2024.11.07 23:57:25 INFO  Deduplicating compilation of root from bsp client 'Metals 1.4.0' (since 3.602s)
2024.11.07 23:57:25 INFO  compiling root (1 scala source)
2024.11.07 23:57:25 INFO  time: compiled root in 0.15s
2024.11.07 23:57:30 INFO  compiling root (1 scala source)
2024.11.07 23:57:30 INFO  time: compiled root in 0.19s
2024.11.07 23:58:28 INFO  compiling root (1 scala source)
2024.11.07 23:58:28 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceSpec.scala
2024.11.07 23:58:28 INFO  time: compiled root in 0.25s
2024.11.07 23:58:28 INFO  compiling root (1 scala source)
2024.11.07 23:58:28 INFO  time: compiled root in 0.13s
2024.11.07 23:58:46 INFO  compiling root (1 scala source)
2024.11.07 23:58:46 INFO  time: compiled root in 0.55s
2024.11.07 23:59:29 INFO  compiling root (1 scala source)
2024.11.07 23:59:29 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.07 23:59:29 INFO  time: compiled root in 0.29s
2024.11.07 23:59:33 INFO  compiling root (1 scala source)
2024.11.07 23:59:33 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.07 23:59:33 INFO  time: compiled root in 0.15s
2024.11.07 23:59:36 INFO  compiling root (1 scala source)
2024.11.07 23:59:36 INFO  time: compiled root in 0.13s
2024.11.07 23:59:51 INFO  skipping build import with status 'Installed'
2024.11.07 23:59:51 INFO  Disconnecting from Bloop session...
2024.11.07 23:59:51 INFO  Shut down connection with build server.
2024.11.07 23:59:51 INFO  Shut down connection with build server.
2024.11.07 23:59:51 INFO  Cancelling compilation on Bloop server
2024.11.07 23:59:51 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:59:51 INFO  Attempting to connect to the build server...
2024.11.07 23:59:51 INFO  Found a Bloop server running
2024.11.07 23:59:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:59:51 INFO  Attempting to connect to the build server...
2024.11.07 23:59:51 INFO  Found a Bloop server running
2024.11.07 23:59:52 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:59:51 INFO  time: Connected to build server in 0.9s
2024.11.07 23:59:51 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:59:52 INFO  running doctor check
2024.11.07 23:59:52 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:59:54 INFO  time: indexed workspace in 1.97s
2024.11.07 23:59:54 INFO  compiling root (1 scala source)
2024.11.07 23:59:54 INFO  time: compiled root in 0.15s
2024.11.07 23:59:55 INFO  skipping build import with status 'Installed'
2024.11.07 23:59:55 INFO  Disconnecting from Bloop session...
2024.11.07 23:59:55 INFO  Cancelling compilation on Bloop server
2024.11.07 23:59:55 INFO  Shut down connection with build server.
2024.11.07 23:59:55 INFO  Shut down connection with build server.
2024.11.07 23:59:55 INFO  Scala main classes not supported by server
2024.11.07 23:59:55 INFO  Scala test classes not supported by server
2024.11.07 23:59:55 INFO  Attempting to connect to the build server...
2024.11.07 23:59:54 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.07 23:59:55 INFO  Found a Bloop server running
2024.11.07 23:59:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:59:55 INFO  Attempting to connect to the build server...
2024.11.07 23:59:55 INFO  Found a Bloop server running
2024.11.07 23:59:56 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.07 23:59:55 INFO  time: Connected to build server in 0.92s
2024.11.07 23:59:55 INFO  Connected to Build server: Bloop v2.0.3
2024.11.07 23:59:56 INFO  running doctor check
2024.11.07 23:59:56 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.07 23:59:58 INFO  time: indexed workspace in 2.06s
2024.11.07 23:59:58 INFO  compiling root (1 scala source)
2024.11.07 23:59:58 INFO  time: compiled hotel-bookinghotel-booking-build in 7ms
2024.11.07 23:59:58 INFO  time: compiled root in 0.16s
2024.11.08 00:00:11 INFO  compiling root (1 scala source)
2024.11.08 00:00:11 INFO  time: compiled root in 0.16s
2024.11.08 00:00:13 INFO  compiling root (1 scala source)
2024.11.08 00:00:13 INFO  time: compiled root in 0.14s
2024.11.08 00:00:59 INFO  Shutting down server
2024.11.08 00:00:59 INFO  shutting down Metals
2024.11.08 00:00:59 INFO  Shut down connection with build server.
2024.11.08 00:00:59 INFO  Shut down connection with build server.
2024.11.08 00:00:59 INFO  Exiting server
2024.11.08 00:01:15 INFO  Started: Metals version 1.4.0 in folders 'C:\Users\User\hotel-bookinghotel-booking' for client Visual Studio Code 1.95.1.
2024.11.08 00:01:15 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.08 00:01:15 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 00:01:17 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 00:01:17 INFO  Attempting to connect to the build server...
2024.11.08 00:01:17 INFO  Found a Bloop server running
2024.11.08 00:01:17 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:01:18 INFO  Attempting to connect to the build server...
2024.11.08 00:01:18 INFO  Found a Bloop server running
2024.11.08 00:01:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:01:18 INFO  time: Connected to build server in 1.39s
2024.11.08 00:01:18 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 00:01:18 INFO  running doctor check
2024.11.08 00:01:18 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.08 00:01:25 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
nov. 08, 2024 12:01:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 22
2024.11.08 00:01:27 INFO  time: indexed workspace in 9.09s
2024.11.08 00:01:27 INFO  compiling root (1 scala source)
2024.11.08 00:01:27 INFO  time: compiled root in 0.32s
2024.11.08 00:01:27 INFO  compiling root (1 scala source)
2024.11.08 00:01:27 INFO  time: compiled root in 0.19s
2024.11.08 00:01:33 INFO  skipping build import with status 'Installed'
2024.11.08 00:01:33 INFO  Disconnecting from Bloop session...
2024.11.08 00:01:33 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.08 00:01:33 INFO  Shut down connection with build server.
2024.11.08 00:01:33 INFO  Shut down connection with build server.
2024.11.08 00:01:33 INFO  Attempting to connect to the build server...
2024.11.08 00:01:33 INFO  Found a Bloop server running
2024.11.08 00:01:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:01:33 INFO  Attempting to connect to the build server...
2024.11.08 00:01:33 INFO  Found a Bloop server running
2024.11.08 00:01:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:01:33 INFO  time: Connected to build server in 0.97s
2024.11.08 00:01:33 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 00:01:34 INFO  running doctor check
2024.11.08 00:01:34 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.08 00:01:36 INFO  time: indexed workspace in 2.15s
2024.11.08 00:01:36 INFO  compiling root (1 scala source)
2024.11.08 00:01:36 INFO  time: compiled root in 0.24s
2024.11.08 00:01:38 INFO  compiling root (1 scala source)
2024.11.08 00:01:38 INFO  time: compiled root in 0.23s
2024.11.08 00:02:29 INFO  compiling root (1 scala source)
2024.11.08 00:02:29 INFO  time: compiled root in 0.23s
2024.11.08 00:02:41 INFO  compiling root (1 scala source)
2024.11.08 00:02:41 INFO  time: compiled root in 0.19s
2024.11.08 00:03:16 INFO  compiling root (2 scala sources)
2024.11.08 00:03:16 INFO  time: compiled root in 0.28s
2024.11.08 00:03:36 INFO  compiling root (3 scala sources)
2024.11.08 00:03:36 INFO  time: compiled root in 0.21s
2024.11.08 00:03:42 INFO  compiling root (3 scala sources)
2024.11.08 00:03:42 INFO  time: compiled root in 0.24s
2024.11.08 00:03:44 INFO  compiling root (3 scala sources)
2024.11.08 00:03:44 INFO  time: compiled root in 0.24s
2024.11.08 00:03:47 INFO  compiling root (3 scala sources)
2024.11.08 00:03:47 INFO  time: compiled root in 0.23s
2024.11.08 00:03:48 INFO  compiling root (3 scala sources)
2024.11.08 00:03:48 INFO  time: compiled root in 0.26s
2024.11.08 00:04:19 INFO  compiling root (3 scala sources)
2024.11.08 00:04:19 INFO  time: compiled root in 0.23s
2024.11.08 00:04:21 INFO  compiling root (3 scala sources)
2024.11.08 00:04:21 INFO  time: compiled root in 0.22s
2024.11.08 00:04:25 INFO  compiling root (3 scala sources)
2024.11.08 00:04:25 INFO  time: compiled root in 0.21s
2024.11.08 00:05:01 INFO  compiling root (3 scala sources)
2024.11.08 00:05:01 INFO  time: compiled root in 0.31s
2024.11.08 00:05:23 INFO  compiling root (3 scala sources)
2024.11.08 00:05:23 INFO  time: compiled root in 0.21s
2024.11.08 00:05:34 INFO  compiling root (3 scala sources)
2024.11.08 00:05:34 INFO  time: compiled root in 0.21s
2024.11.08 00:05:44 INFO  compiling root (3 scala sources)
2024.11.08 00:05:44 INFO  time: compiled root in 0.2s
2024.11.08 00:06:37 WARN  Could not find 'ScalaFutures' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.08 00:07:36 INFO  compiling root (2 scala sources)
2024.11.08 00:07:38 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/MyServiceTest.scala
2024.11.08 00:07:38 INFO  time: compiled root in 1.15s
2024.11.08 00:09:16 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals6650522942552658049\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.08 00:09:17 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.08 00:09:17 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.08 00:09:19 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.08 00:09:19 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.08 00:09:20 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.08 00:09:22 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.08 00:09:22 INFO  [success] Total time: 2 s, completed 8 de nov de 2024 00:09:22
2024.11.08 00:09:25 INFO  [info] loading settings for project root from build.sbt ...
2024.11.08 00:09:25 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.08 00:09:25 INFO  [success] Generated .bloop\root.json
2024.11.08 00:09:25 INFO  [success] Generated .bloop\root-test.json
2024.11.08 00:09:25 INFO  [success] Total time: 1 s, completed 8 de nov de 2024 00:09:26
2024.11.08 00:09:26 INFO  time: ran 'sbt bloopInstall' in 10s
2024.11.08 00:09:26 INFO  Disconnecting from Bloop session...
2024.11.08 00:09:26 INFO  Shut down connection with build server.
2024.11.08 00:09:26 INFO  Shut down connection with build server.
2024.11.08 00:09:26 INFO  Attempting to connect to the build server...
2024.11.08 00:09:26 INFO  Found a Bloop server running
2024.11.08 00:09:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:09:26 INFO  Attempting to connect to the build server...
2024.11.08 00:09:26 INFO  Found a Bloop server running
2024.11.08 00:09:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:09:27 INFO  time: Connected to build server in 0.96s
2024.11.08 00:09:27 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 00:09:27 INFO  running doctor check
2024.11.08 00:09:27 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.08 00:09:29 INFO  time: indexed workspace in 1.88s
2024.11.08 00:09:29 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.08 00:09:29 INFO  BSP server: 
Found names but no class, trait or object is defined in the compilation unit.
The incremental compiler cannot record the dependency information in such case.
Some errors like unused import referring to a non-existent class might not be reported.
    
2024.11.08 00:09:29 INFO  compiling root-test (1 scala source)
2024.11.08 00:09:29 INFO  time: compiled root-test in 0.28s
2024.11.08 00:09:45 INFO  skipping build import with status 'Installed'
2024.11.08 00:09:45 INFO  Disconnecting from Bloop session...
2024.11.08 00:09:45 INFO  Shut down connection with build server.
2024.11.08 00:09:45 INFO  Cancelling compilation on Bloop server
2024.11.08 00:09:45 INFO  Shut down connection with build server.
2024.11.08 00:09:45 INFO  Attempting to connect to the build server...
2024.11.08 00:09:45 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.11.08 00:09:45 INFO  Found a Bloop server running
2024.11.08 00:09:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:09:45 INFO  Attempting to connect to the build server...
2024.11.08 00:09:45 INFO  Found a Bloop server running
2024.11.08 00:09:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:09:45 INFO  time: Connected to build server in 0.98s
2024.11.08 00:09:45 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 00:09:46 INFO  running doctor check
2024.11.08 00:09:46 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.08 00:09:48 INFO  time: indexed workspace in 1.83s
2024.11.08 00:09:57 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.08 00:09:57 INFO  BSP server: 
Found names but no class, trait or object is defined in the compilation unit.
The incremental compiler cannot record the dependency information in such case.
Some errors like unused import referring to a non-existent class might not be reported.
    
2024.11.08 00:09:57 INFO  time: compiled hotel-bookinghotel-booking-build in 20ms
2024.11.08 00:09:57 INFO  compiling root-test (1 scala source)
2024.11.08 00:09:57 INFO  time: compiled root-test in 0.19s
2024.11.08 00:11:07 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals13900464359614375171\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.08 00:11:08 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.08 00:11:08 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.08 00:11:10 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.08 00:11:10 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.08 00:11:10 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.08 00:11:13 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.08 00:11:13 INFO  [success] Total time: 2 s, completed 8 de nov de 2024 00:11:13
2024.11.08 00:11:16 INFO  [info] loading settings for project root from build.sbt ...
2024.11.08 00:11:16 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.08 00:11:16 INFO  [success] Generated .bloop\root.json
2024.11.08 00:11:16 INFO  [success] Generated .bloop\root-test.json
2024.11.08 00:11:16 INFO  [success] Total time: 0 s, completed 8 de nov de 2024 00:11:17
2024.11.08 00:11:17 INFO  time: ran 'sbt bloopInstall' in 10s
2024.11.08 00:11:17 INFO  Disconnecting from Bloop session...
2024.11.08 00:11:17 INFO  Shut down connection with build server.
2024.11.08 00:11:17 INFO  Shut down connection with build server.
2024.11.08 00:11:17 INFO  Attempting to connect to the build server...
2024.11.08 00:11:17 INFO  Found a Bloop server running
2024.11.08 00:11:17 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:11:17 INFO  Attempting to connect to the build server...
2024.11.08 00:11:17 INFO  Found a Bloop server running
2024.11.08 00:11:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:11:17 INFO  time: Connected to build server in 0.98s
2024.11.08 00:11:17 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 00:11:18 INFO  running doctor check
2024.11.08 00:11:18 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.08 00:11:20 INFO  time: indexed workspace in 2.03s
2024.11.08 00:11:20 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.08 00:11:20 INFO  BSP server: 
Found names but no class, trait or object is defined in the compilation unit.
The incremental compiler cannot record the dependency information in such case.
Some errors like unused import referring to a non-existent class might not be reported.
    
2024.11.08 00:11:20 INFO  compiling root-test (1 scala source)
2024.11.08 00:11:20 INFO  time: compiled root-test in 0.22s
2024.11.08 00:13:49 INFO  compiling root (1 scala source)
2024.11.08 00:13:49 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.08 00:13:49 INFO  time: compiled root in 0.95s
2024.11.08 00:16:46 INFO  compiling root-test (1 scala source)
2024.11.08 00:16:46 INFO  time: compiled root-test in 0.24s
2024.11.08 00:17:00 INFO  compiling root-test (1 scala source)
2024.11.08 00:17:00 INFO  time: compiled root-test in 0.16s
2024.11.08 00:17:32 INFO  running 'C:\Users\User\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin11-binaries\releases\download\jdk-11.0.25%252B9\OpenJDK11U-jdk_x64_windows_hotspot_11.0.25_9.zip\jdk-11.0.25+9\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals1096315977062318644\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.11.08 00:17:34 INFO  [info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 11.0.25)
2024.11.08 00:17:34 INFO  [info] loading settings for project hotel-bookinghotel-booking-build-build from metals.sbt ...
2024.11.08 00:17:36 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project\project
2024.11.08 00:17:36 INFO  [info] loading settings for project hotel-bookinghotel-booking-build from metals.sbt ...
2024.11.08 00:17:37 INFO  [info] loading project definition from C:\Users\User\hotel-bookinghotel-booking\project
2024.11.08 00:17:39 INFO  [success] Generated .bloop\hotel-bookinghotel-booking-build.json
2024.11.08 00:17:39 INFO  [success] Total time: 3 s, completed 8 de nov de 2024 00:17:39
2024.11.08 00:17:42 INFO  [info] loading settings for project root from build.sbt ...
2024.11.08 00:17:42 INFO  [info] set current project to hotel-booking (in build file:/C:/Users/User/hotel-bookinghotel-booking/)
2024.11.08 00:17:45 INFO  [success] Generated .bloop\root.json
2024.11.08 00:17:45 INFO  [success] Generated .bloop\root-test.json
2024.11.08 00:17:45 INFO  [success] Total time: 2 s, completed 8 de nov de 2024 00:17:45
2024.11.08 00:17:45 INFO  time: ran 'sbt bloopInstall' in 12s
2024.11.08 00:17:45 INFO  Disconnecting from Bloop session...
2024.11.08 00:17:45 INFO  Shut down connection with build server.
2024.11.08 00:17:45 INFO  Shut down connection with build server.
2024.11.08 00:17:45 INFO  Attempting to connect to the build server...
2024.11.08 00:17:45 INFO  Found a Bloop server running
2024.11.08 00:17:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:17:45 INFO  Attempting to connect to the build server...
2024.11.08 00:17:45 INFO  Found a Bloop server running
2024.11.08 00:17:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 00:17:45 INFO  time: Connected to build server in 0.97s
2024.11.08 00:17:45 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 00:17:46 INFO  running doctor check
2024.11.08 00:17:46 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.08 00:17:48 INFO  time: indexed workspace in 1.78s
2024.11.08 00:17:48 INFO  compiling root (2 scala sources)
2024.11.08 00:17:49 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.08 00:17:49 INFO  time: compiled root in 1.12s
2024.11.08 00:52:23 INFO  Shutting down server
2024.11.08 00:52:23 INFO  shutting down Metals
2024.11.08 00:52:23 INFO  Shut down connection with build server.
2024.11.08 00:52:23 INFO  Shut down connection with build server.
2024.11.08 00:52:23 INFO  Exiting server
2024.11.08 12:02:42 INFO  Started: Metals version 1.4.0 in folders 'C:\Users\User\hotel-bookinghotel-booking' for client Visual Studio Code 1.95.2.
2024.11.08 12:02:42 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.08 12:02:43 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\dao\ReservationDAO.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:43 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Room.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:43 INFO  Attempting to connect to the build server...
2024.11.08 12:02:43 INFO  No running Bloop server found, starting one.
2024.11.08 12:02:46 INFO  Starting compilation server
2024.11.08 12:02:47 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\dao\ReservationDAO.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:47 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\dao\ReservationDAO.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:47 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\dao\ReservationDAO.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:47 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\dao\ReservationDAO.scala. Using presentation compiler with project's scala-library version: 3.3.4
nov. 08, 2024 12:02:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10
nov. 08, 2024 12:02:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8
2024.11.08 12:02:47 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Room.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:49 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Reservation.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:49 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\models\Reservation.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:52 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:52 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:52 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 12:02:54 INFO  no build target found for C:\Users\User\hotel-bookinghotel-booking\src\main\scala\controllers\RoomController.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.08 12:02:54 INFO  Attempting to connect to the build server...
2024.11.08 12:02:54 INFO  Found a Bloop server running
2024.11.08 12:02:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\hotel-bookinghotel-booking\project\.metals\bsp.trace.json or C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.08 12:02:55 INFO  time: Connected to build server in 11s
2024.11.08 12:02:55 INFO  Connected to Build server: Bloop v2.0.3
2024.11.08 12:02:55 INFO  time: Imported build in 0.19s
2024.11.08 12:02:55 INFO  running doctor check
2024.11.08 12:02:55 INFO  java targets: hotel-bookinghotel-booking-build, root-test, root
2024.11.08 12:03:04 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.08 12:03:14 INFO  time: indexed workspace in 19s
2024.11.08 12:03:16 INFO  compiling hotel-bookinghotel-booking-build (1 scala source)
2024.11.08 12:03:16 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.08 12:03:16 INFO  BSP server: 
Found names but no class, trait or object is defined in the compilation unit.
The incremental compiler cannot record the dependency information in such case.
Some errors like unused import referring to a non-existent class might not be reported.
    
2024.11.08 12:03:23 INFO  time: compiled hotel-bookinghotel-booking-build in 7.61s
2024.11.08 12:09:00 INFO  compiling root (1 scala source)
2024.11.08 12:09:04 WARN  Invalid text document uri received from build server: file:///C:/Users/User/hotel-bookinghotel-booking/src/main/scala/services/ReservationServiceTest.scala
2024.11.08 12:09:04 INFO  time: compiled root in 3.97s
2024.11.08 12:13:11 INFO  Shutting down server
2024.11.08 12:13:11 INFO  shutting down Metals
2024.11.08 12:13:11 INFO  Shut down connection with build server.
2024.11.08 12:13:11 INFO  Shut down connection with build server.
2024.11.08 12:13:11 INFO  Exiting server
